Improved Unsupervised POS Induction through Prototype Discovery
Omri Abend1∗ Roi Reichart2
1

Ari Rappoport1

Institute of Computer Science, 2 ICNC
Hebrew University of Jerusalem

{omria01|roiri|arir}@cs.huji.ac.il

Abstract

central members. Our algorithm ﬁrst clusters
words based on a ﬁne morphological representation. It then clusters the most frequent words,
deﬁning landmark clusters which constitute the
cores of the categories. Finally, it maps the rest
of the words to these categories. The last two
stages utilize a distributional representation that
has been shown to be effective for unsupervised
parsing (Seginer, 2007).
We evaluated the algorithm in both English and
German, using four different mapping-based and
information theoretic clustering evaluation measures. The results obtained are generally better
than all existing POS induction algorithms.
Section 2 reviews related work. Sections 3 and
4 detail the algorithm. Sections 5, 6 and 7 describe
the evaluation, experimental setup and results.

We present a novel fully unsupervised algorithm for POS induction from plain text,
motivated by the cognitive notion of prototypes. The algorithm ﬁrst identiﬁes landmark clusters of words, serving as the
cores of the induced POS categories. The
rest of the words are subsequently mapped
to these clusters. We utilize morphological and distributional representations
computed in a fully unsupervised manner.
We evaluate our algorithm on English and
German, achieving the best reported results for this task.

1

Introduction

Part-of-speech (POS) tagging is a fundamental
NLP task, used by a wide variety of applications.
However, there is no single standard POS tagging scheme, even for English. Schemes vary
signiﬁcantly across corpora and even more so
across languages, creating difﬁculties in using
POS tags across domains and for multi-lingual
systems (Jiang et al., 2009). Automatic induction
of POS tags from plain text can greatly alleviate
this problem, as well as eliminate the efforts incurred by manual annotations. It is also a problem
of great theoretical interest. Consequently, POS
induction is a vibrant research area (see Section 2).
In this paper we present an algorithm based
on the theory of prototypes (Taylor, 2003), which
posits that some members in cognitive categories
are more central than others. These practically deﬁne the category, while the membership of other
elements is based on their association with the
∗
Omri Abend is grateful to the Azrieli Foundation for
the award of an Azrieli Fellowship.

2 Related Work
Unsupervised and semi-supervised POS tagging
have been tackled using a variety of methods.
Sch¨ tze (1995) applied latent semantic analysis.
u
The best reported results (when taking into account all evaluation measures, see Section 5) are
given by (Clark, 2003), which combines distributional and morphological information with
the likelihood function of the Brown algorithm
(Brown et al., 1992). Clark’s tagger is very sensitive to its initialization. Reichart et al. (2010b)
propose a method to identify the high quality runs
of this algorithm. In this paper, we show that
our algorithm outperforms not only Clark’s mean
performance, but often its best among 100 runs.
Most research views the task as a sequential labeling problem, using HMMs (Merialdo, 1994;
Banko and Moore, 2004; Wang and Schuurmans,
2005) and discriminative models (Smith and Eisner, 2005; Haghighi and Klein, 2006). Several

1298
Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 1298–1307,
Uppsala, Sweden, 11-16 July 2010. c 2010 Association for Computational Linguistics

techniques were proposed to improve the HMM
model. A Bayesian approach was employed by
(Goldwater and Grifﬁths, 2007; Johnson, 2007;
Gao and Johnson, 2008). Van Gael et al. (2009)
used the inﬁnite HMM with non-parametric priors. Graca et al. (2009) biased the model to induce
¸
a small number of possible tags for each word.
The idea of utilizing seeds and expanding them
to less reliable data has been used in several papers. Haghighi and Klein (2006) use POS ‘prototypes’ that are manually provided and tailored
to a particular POS tag set of a corpus. Freitag (2004) and Biemann (2006) induce an initial clustering and use it to train an HMM model.
Dasgupta and Ng (2007) generate morphological
clusters and use them to bootstrap a distributional
model. Goldberg et al. (2008) use linguistic considerations for choosing a good starting point for
the EM algorithm. Zhao and Marcus (2009) expand a partial dictionary and use it to learn disambiguation rules. Their evaluation is only at the
type level and only for half of the words. Ravi
and Knight (2009) use a dictionary and an MDLinspired modiﬁcation to the EM algorithm.
Many of these works use a dictionary providing allowable tags for each or some of the words.
While this scenario might reduce human annotation efforts, it does not induce a tagging scheme
but remains tied to an existing one. It is further
criticized in (Goldwater and Grifﬁths, 2007).
Morphological representation. Many POS induction models utilize morphology to some extent. Some use simplistic representations of terminal letter sequences (e.g., (Smith and Eisner, 2005;
Haghighi and Klein, 2006)). Clark (2003) models
the entire letter sequence as an HMM and uses it
to deﬁne a morphological prior. Dasgupta and Ng
(2007) use the output of the Morfessor segmentation algorithm for their morphological representation. Morfessor (Creutz and Lagus, 2005), which
we use here as well, is an unsupervised algorithm
that segments words and classiﬁes each segment
as being a stem or an afﬁx. It has been tested on
several languages with strong results.
Our work has several unique aspects. First,
our clustering method discovers prototypes in a
fully unsupervised manner, mapping the rest of
the words according to their association with the
prototypes. Second, we use a distributional representation which has been shown to be effective for
unsupervised parsing (Seginer, 2007). Third, we

use a morphological representation based on signatures, which are sets of afﬁxes that represent a
family of words sharing an inﬂectional or derivational morphology (Goldsmith, 2001).

3 Distributional Algorithm
Our algorithm is given a plain text corpus and optionally a desired number of clusters k. Its output
is a partitioning of words into clusters. The algorithm utilizes two representations, distributional
and morphological. Although eventually the latter
is used before the former, for clarity of presentation we begin by detailing the base distributional
algorithm. In the next section we describe the morphological representation and its integration into
the base algorithm.
Overview. The algorithm consists of two main
stages: landmark clusters discovery, and word
mapping. For the former, we ﬁrst compute a distributional representation for each word. We then
cluster the coordinates corresponding to high frequency words. Finally, we deﬁne landmark clusters. In the word mapping stage we map each word
to the most similar landmark cluster.
The rationale behind using only the high frequency words in the ﬁrst stage is twofold. First,
prototypical members of a category are frequent
(Taylor, 2003), and therefore we can expect the
salient POS tags to be represented in this small
subset. Second, higher frequency implies more reliable statistics. Since this stage determines the
cores of all resulting clusters, it should be as accurate as possible.
Distributional representation. We use a simpliﬁed form of the elegant representation of lexical entries used by the Seginer unsupervised parser
(Seginer, 2007). Since a POS tag reﬂects the
grammatical role of the word and since this representation is effective to parsing, we were motivated to apply it to the present task.
Let W be the set of word types in the corpus.
The right context entry of a word x ∈ W is a pair
of mappings r intx : W → [0, 1] and r adjx :
W → [0, 1]. For each w ∈ W , r adjx (w) is an
adjacency score of w to x, reﬂecting w’s tendency
to appear on the right hand side of x.
For each w ∈ W , r intx (w) is an interchangeability score of x with w, reﬂecting the tendency
of w to appear to the left of words that tend to appear to the right of x. This can be viewed as a

1299

similarity measure between words with respect to
their right context. The higher the scores the more
the words tend to be adjacent/interchangeable.
Left context parameters l intx and l adjx are
deﬁned analogously.
There are important subtleties in these deﬁnitions. First, for two words x, w ∈ W , r adjx (w)
is generally different from l adjw (x). For example, if w is a high frequency word and x is a low
frequency word, it is likely that w appears many
times to the right of x, yielding a high r adjx (w),
but that x appears only a few times to the left of w
yielding a low l adjw (x). Second, from the deﬁnition of r intx (w) and r intw (x), it is clear that
they need not be equal.
These functions are computed incrementally by
a bootstrapping process. We initialize all mappings to be identically 0. We iterate over the words
in the training corpus. For every word instance x,
we take the word immediately to its right y and
update x’s right context using y’s left context:
l adjy (w)
∀w ∈ W : r intx (w) +=
N (y)
1
w=y
∀w ∈ W : r adjx (w) += l inty (w)
w=y
N (y)
The division by N (y) (the number of times y
appears in the corpus before the update) is done in
order not to give a disproportional weight to high
frequency words. Also, r intx (w) and r adjx (w)
might become larger than 1. We therefore normalize them after all updates are performed by the
number of occurrences of x in the corpus.
We update l intx and l adjx analogously using
the word z immediately to the left of x. The updates of the left and right functions are done in
parallel.
We deﬁne the distributional representation of a
word type x to be a 4|W | + 2 dimensional vector
vx . Each word w yields four coordinates, one for
each direction (left/right) and one for each mapping type (int/adj). Two additional coordinates
represent the frequency in which the word appears
to the left and to the right of a stopping punctuation. Of the 4|W | coordinates corresponding
to words, we allow only 2n to be non-zero: the
n top scoring among the right side coordinates
(those of r intx and r adjx ), and the n top scoring
among the left side coordinates (those of l intx
and l adjx ). We used n = 50.
The distance between two words is deﬁned to
be one minus the cosine of the angle between their

representation vectors.
Coordinate clustering. Each of our landmark
clusters will correspond to a set of high frequency
words (HFWs). The number of HFWs is much
larger than the number of expected POS tags.
Hence we should cluster HFWs. Our algorithm
does that by unifying some of the non-zero coordinates corresponding to HFWs in the distributional
representation deﬁned above.
We extract the words that appear more than N
times per million1 and apply the following procedure I times (5 in our experiments).
We run average link clustering with a threshold
α (AVGLINKα , (Jain et al., 1999)) on these words,
in each iteration initializing every HFW to have
its own cluster. AVGLINKα means running the average link algorithm until the two closest clusters
have a distance larger than α. We then use the induced clustering to update the distributional representation, by collapsing all coordinates corresponding to words appearing in the same cluster
into a single coordinate whose value is the sum
of the collapsed coordinates’ values. In order to
produce a conservative (ﬁne) clustering, we used a
relatively low α value of 0.25.
Note that the AVGLINKα initialization in each
of the I iterations assigns each HFW to a separate cluster. The iterations differ in the distributional representation of the HFWs, resulting from
the previous iterations.
In our English experiments, this process reduced the dimension of the HFWs set (the number of coordinates that are non-zero in at least one
of the HFWs) from 14365 to 10722. The average number of non-zero coordinates per word decreased from 102 to 55.
Since all eventual POS categories correspond to
clusters produced at this stage, to reduce noise we
delete clusters of less than ﬁve elements.
Landmark detection. We deﬁne landmark clusters using the clustering obtained in the ﬁnal iteration of the coordinate clustering stage. However,
the number of clusters might be greater than the
desired number k, which is an optional parameter of the algorithm. In this case we select a subset of k clusters that best covers the HFW space.
We use the following heuristic. We start from the
most frequent cluster, and greedily select the clus1
We used N = 100, yielding 1242 words for English and
613 words for German.

1300

ter farthest from the clusters already selected. The
distance between two clusters is deﬁned to be the
average distance between their members. A cluster’s distance from a set of clusters is deﬁned to
be its minimal distance from the clusters in the
set. The ﬁnal set of clusters {L1 , ..., Lk } and their
members are referred to as landmark clusters and
prototypes, respectively.
Mapping all words. Each word w ∈ W is assigned the cluster Li that contains its nearest prototype:
d(w, Li ) = minx∈Li {1 − cos(vw , vx )}
M ap(w) = argminLi {d(w, Li )}
Words that appear less than 5 times are considered as unknown words. We consider two schemes
for handling unknown words. One randomly maps
each such word to a cluster, using a probability proportional to the number of unique known
words already assigned to that cluster. However,
when the number k of landmark clusters is relatively large, it is beneﬁcial to assign all unknown
words to a separate new cluster (after running the
algorithm with k − 1). In our experiments, we use
the ﬁrst option when k is below some threshold
(we used 15), otherwise we use the second.

4

Morphological Model

The morphological model generates another word
clustering, based on the notion of a signature.
This clustering is integrated with the distributional
model as described below.

Types
Stem
Afﬁxes
Signature

join
join
φ

joins joined joining
join
join
join
s
ed
ing
{φ, ed, s, ing}

Figure 1: An example for a morphological representation,
deﬁned to be the conjunction of its afﬁx(es) with the stem’s
signature.

In addition, we incorporate capitalization information into the model, by constraining all words
that appear capitalized in more than half of their
instances to belong to a separate cluster, regardless of their morphological representation. The
motivation for doing so is practical: capitalization
is used in many languages to mark grammatical
categories. For instance, in English capitalization
marks the category of proper names and in German it marks the noun category . We report English results both with and without this modiﬁcation.
Words that contain non-alphanumeric characters are represented as the sequence of the nonalphanumeric characters they include, e.g., ‘vis-` a
vis’ is represented as (“-”, “-”). We do not assign a morphological representation to words including more than one stem (like weatherman), to
words that have a null afﬁx (i.e., where the word
is identical to its stem) and to words whose stem
is not shared by any other word (signature of size
1). Words that were not assigned a morphological representation are included as singletons in the
morphological clustering.
4.2 Distributional-Morphological Algorithm

4.1 Morphological Representation
We use the Morfessor (Creutz and Lagus, 2005)
word segmentation algorithm. First, all words in
the corpus are segmented. Then, for each stem,
the set of all afﬁxes with which it appears (its signature, (Goldsmith, 2001)) is collected. The morphological representation of a word type is then
deﬁned to be its stem’s signature in conjunction
with its speciﬁc afﬁxes2 (See Figure 1).
We now collect all words having the same representation. For instance, if the words joined and
painted are found to have the same signature, they
would share the same cluster since both have the
afﬁx ‘ ed’. The word joins does not share the same
cluster with them since it has a different afﬁx, ‘ s’.
This results in coarse-grained clusters exclusively
deﬁned according to morphology.
2

A word may contain more than a single afﬁx.

We detail the modiﬁcations made to our base
distributional algorithm given the morphological
clustering deﬁned above.
Coordinate clustering and landmarks. We
constrain AVGLINKα to begin by forming links between words appearing in the same morphological cluster. Only when the distance between the
two closest clusters gets above α we remove this
constraint and proceed as before. This is equivalent to performing AVGLINKα separately within
each morphological cluster and then using the result as an initial condition for an AVGLINKα coordinate clustering. The modiﬁed algorithm in this
stage is otherwise identical to the distributional algorithm.
Word mapping. In this stage words that are not
prototypes are mapped to one of the landmark

1301

clusters. A reasonable strategy would be to map
all words sharing a morphological cluster as a single unit. However, these clusters are too coarsegrained. We therefore begin by partitioning the
morphological clusters into sub-clusters according
to their distributional behavior. We do so by applying AVGLINKβ (the same as AVGLINKα but with a
different parameter) to each morphological cluster. Since our goal is cluster reﬁnement, we use a
β that is considerably higher than α (0.9).
We then ﬁnd the closest prototype to each such
sub-cluster (averaging the distance across all of
the latter’s members) and map it as a single unit
to the cluster containing that prototype.

5

Clustering Evaluation

We evaluate the clustering produced by our algorithm using an external quality measure: we take
a corpus tagged by gold standard tags, tag it using
the induced tags, and compare the two taggings.
There is no single accepted measure quantifying
the similarity between two taggings. In order to
be as thorough as possible, we report results using
four known measures, two mapping-based measures and two information theoretic ones.
Mapping-based measures. The induced clusters have arbitrary names. We deﬁne two mapping schemes between them and the gold clusters. After the induced clusters are mapped, we
can compute a derived accuracy. The Many-to-1
measure ﬁnds the mapping between the gold standard clusters and the induced clusters which maximizes accuracy, allowing several induced clusters
to be mapped to the same gold standard cluster.
The 1-to-1 measure ﬁnds the mapping between
the induced and gold standard clusters which maximizes accuracy such that no two induced clusters are mapped to the same gold cluster. Computing this mapping is equivalent to ﬁnding the
maximal weighted matching in a bipartite graph,
whose weights are given by the intersection sizes
between matched classes/clusters. As in (Reichart
and Rappoport, 2008), we use the Kuhn-Munkres
algorithm (Kuhn, 1955; Munkres, 1957) to solve
this problem.
Information theoretic measures. These are
based on the observation that a good clustering reduces the uncertainty of the gold tag given the induced cluster, and vice-versa. Several such measures exist; we use V (Rosenberg and Hirschberg,

2007) and NVI (Reichart and Rappoport, 2009),
VI’s (Meila, 2007) normalized version.

6 Experimental Setup
Since a goal of unsupervised POS tagging is inducing an annotation scheme, comparison to an
existing scheme is problematic. To address this
problem we compare to three different schemes
in two languages. In addition, the two English
schemes we compare with were designed to tag
corpora contained in our training set, and have
been widely and successfully used with these corpora by a large number of applications.
Our algorithm was run with the exact same parameters on both languages: N = 100 (high frequency threshold), n = 50 (the parameter that
determines the effective number of coordinates),
α = 0.25 (cluster separation during landmark
cluster generation), β = 0.9 (cluster separation
during reﬁnement of morphological clusters).
The algorithm we compare with in most detail
is (Clark, 2003), which reports the best current
results for this problem (see Section 7). Since
Clark’s algorithm is sensitive to its initialization,
we ran it a 100 times and report its average and
standard deviation in each of the four measures.
In addition, we report the percentile in which our
result falls with respect to these 100 runs.
Punctuation marks are very frequent in corpora
and are easy to cluster. As a result, including them
in the evaluation greatly inﬂates the scores. For
this reason we do not assign a cluster to punctuation marks and we report results using this policy,
which we recommend for future work. However,
to be able to directly compare with previous work,
we also report results for the full POS tag set.
We do so by assigning a singleton cluster to each
punctuation mark (in addition to the k required
clusters). This simple heuristic yields very high
performance on punctuation, scoring (when all
other words are assumed perfect tagging) 99.6%
(99.1%) 1-to-1 accuracy when evaluated against
the English ﬁne (coarse) POS tag sets, and 97.2%
when evaluated against the German POS tag set.
For English, we trained our model on the
39832 sentences which constitute sections 2-21 of
the PTB-WSJ and on the 500K sentences from
the NYT section of the NANC newswire corpus
(Graff, 1995). We report results on the WSJ part
of our data, which includes 950028 words tokens
in 44389 types. Of the tokens, 832629 (87.6%)

1302

English

Many–to–1
1–to–1
NVI
V

Fine k=13
Prototype
Clark
Tagger
µ
σ
61.0
55.1
1.6
55.5
48.8
1.8
60.0
52.2
1.9
54.9
46.0
2.2
0.652
0.773 0.027
0.795
0.943 0.033
0.636
0.581 0.015
0.542
0.478 0.019
German
Prototype
Tagger
Many–to-1
64.6
58.9
1–to–1
53.7
48.0
NVI
0.667
0.819
V
0.646
0.552

Prototype
Tagger
70.0
66.1
58.1
53.7
0.841
1.052
0.590
0.484

%
100
100
100
100
100
100
100
100
k=17
Clark
µ
σ
64.7
1.2
59.1
1.4
52.0
1.8
46.0
2.3
0.675 0.019
0.829 0.025
0.645 0.010
0.553 0.013

Coarse k=13
Clark
µ
σ
66.9
2.1
62.6
2.3
49.4
2.9
43.8
3.3
0.972 0.036
1.221 0.046
0.543 0.018
0.429 0.023

%
41
40
77
78
66
66
50
48

Prototype
Tagger
68.2
63.2
56.0
50.7
0.640
0.785
0.675
0.596

Prototype
Tagger
71.6
67.5
63.5
58.8
0.663
0.809
0.677
0.608

%
94
94
100
100
100
100
100
100
k=26
Clark
µ
σ
67.8
1.0
62.8
1.2
52.0
2.1
45.9
2.6
0.682 0.019
0.839 0.025
0.657 0.008
0.574 0.010

Fine k=34
Clark
µ
σ
69.8
1.5
65.5
1.7
54.5
1.6
48.5
1.8
0.725 0.018
0.885 0.022
0.659 0.008
0.588 0.010

%
90
90
100
100
100
100
100
98

%
60
60
99
99
100
100
100
100

Table 1: Top: English. Bottom: German. Results are reported for our model (Prototype Tagger), Clark’s average score (µ),
Clark’s standard deviation (σ) and the fraction of Clark’s results that scored worse than our model (%). For the mapping based
measures, results are accuracy percentage. For V ∈ [0, 1], higher is better. For high quality output, N V I ∈ [0, 1] as well, and
lower is better. In each entry, the top number indicates the score when including punctuation and the bottom number the score
when excluding it. In English, our results are always better than Clark’s. In German, they are almost always better.
are not punctuation. The percentage of unknown
words (those appearing less than ﬁve times) is
1.6%. There are 45 clusters in this annotation
scheme, 34 of which are not punctuation.
We ran each algorithm both with k=13 and
k=34 (the number of desired clusters). We compare the output to two annotation schemes: the ﬁne
grained PTB WSJ scheme, and the coarse grained
tags deﬁned in (Smith and Eisner, 2005). The
output of the k=13 run is evaluated both against
the coarse POS tag annotation (the ‘Coarse k=13’
scenario) and against the full PTB-WSJ annotation
scheme (the ‘Fine k=13’ scenario). The k=34 run
is evaluated against the full PTB-WSJ annotation
scheme (the ‘Fine k=34’ scenario).
The POS cluster frequency distribution tends to
be skewed: each of the 13 most frequent clusters
in the PTB-WSJ cover more than 2.5% of the tokens (excluding punctuation) and together 86.3%
of them. We therefore chose k=13, since it is both
the number of coarse POS tags (excluding punctuation) as well as the number of frequent POS tags
in the PTB-WSJ annotation scheme. We chose
k=34 in order to evaluate against the full 34 tags
PTB-WSJ annotation scheme (excluding punctuation) using the same number of clusters.
For German, we trained our model on the 20296
sentences of the NEGRA corpus (Brants, 1997)
and on the ﬁrst 450K sentences of the DeWAC

corpus (Baroni et al., 2009). DeWAC is a corpus extracted by web crawling and is therefore
out of domain. We report results on the NEGRA
part, which includes 346320 word tokens of 49402
types. Of the tokens, 289268 (83.5%) are not
punctuation. The percentage of unknown words
(those appearing less than ﬁve times) is 8.1%.
There are 62 clusters in this annotation scheme,
51 of which are not punctuation.
We ran the algorithms with k=17 and k=26.
k=26 was chosen since it is the number of clusters that cover each more than 0.5% of the NEGRA tokens, and in total cover 96% of the (nonpunctuation) tokens. In order to test our algorithm in another scenario, we conducted experiments with k=17 as well, which covers 89.9% of
the tokens. All outputs are compared against NEGRA’s gold standard scheme.
We do not report results for k=51 (where the
number of gold clusters is the same as the number
of induced clusters), since our algorithm produced
only 42 clusters in the landmark detection stage.
We could of course have modiﬁed the parameters to allow our algorithm to produce 51 clusters.
However, we wanted to use the exact same parameters as those used for the English experiments to
minimize the issue of parameter tuning.
In addition to the comparisons described above,
we present results of experiments (in the ‘Fine

1303

M-to-1
1-to-1
NVI
V

B
53.3
50.2
0.782
0.569

B+M
54.8
51.7
0.720
0.598

B+C
58.2
55.1
0.710
0.615

F(I=1)
57.3
54.8
0.742
0.597

F
61.0
60.0
0.652
0.636

1
0.8
0.6
Gold Standard
0.4

Table 2: A comparison of partial versions of the model in
the ‘Fine k=13’ WSJ scenario. M-to-1 and 1-to-1 results are
reported in accuracy percentage. Lower NVI is better. B is the
strictly distributional algorithm, B+M adds the morphological model, B+C adds capitalization to B, F(I=1) consists of
all components, where only one iteration of coordinate clustering is performed, and F is the full model.

Prototype
Clark
HK
J
GG
GJ
VG
GGTP-45
GGTP-17

M-to-1
71.6
69.8
–
43–62
–
–
–
65.4
70.2

1-to-1
63.5
54.5
41.3
37–47
–
40–49.9
–
44.5
49.5

V
0.677
0.659
–
–
–
–
0.54-0.59
–
–

VI
2.00
2.18
–
4.23–5.74
2.8
4.03–4.47
2.5–2.9
–
–

Table 4: Comparison of our algorithms with the recent fully
unsupervised POS taggers for which results are reported. The
models differ in the annotation scheme, the corpus size and
the number of induced clusters (k) that they used. HK:
(Haghighi and Klein, 2006), 193K tokens, ﬁne tags, k=45.
GG: (Goldwater and Grifﬁths, 2007), 24K tokens, coarse
tags, k=17. J : (Johnson, 2007), 1.17M tokens, ﬁne tags,
k=25–50. GJ: (Gao and Johnson, 2008), 1.17M tokens, ﬁne
tags, k=50. VG: (Van Gael et al., 2009), 1.17M tokens, ﬁne
tags, k=47–192. GGTP-45: (Graca et al., 2009), 1.17M to¸
kens, ﬁne tags, k=45. GGTP-17: (Graca et al., 2009), 1.17M
¸
tokens, coarse tags, k=17. Lower VI values indicate better
clustering. VI is computed using e as the base of the logarithm. Our algorithm gives the best results.

k=13’ scenario) that quantify the contribution of
each component of the algorithm. We ran the base
distributional algorithm, a variant which uses only
capitalization information (i.e., has only one nonsingleton morphological class, that of words appearing capitalized in most of their instances) and
a variant which uses no capitalization information,
deﬁning the morphological clusters according to
the morphological representation alone.

7

Results

Table 1 presents results for the English and German experiments. For English, our algorithm obtains better results than Clark’s in all measures and
scenarios. It is without exception better than the
average score of Clark’s and in most cases better
than the maximal Clark score obtained in 100 runs.
A signiﬁcant difference between our algorithm
and Clark’s is that the latter, like most algorithms
which addressed the task, induces the clustering

Induced

0.2

0
0

5

10

15

20

25

30

35

40

45

Figure 2: POS class frequency distribution for our model
and the gold standard, in the ‘Fine k=34’ scenario. The distributions are similar.

by maximizing a non-convex function. These
functions have many local maxima and the speciﬁc
solution to which algorithms that maximize them
converge strongly depends on their (random) initialization. Therefore, their output’s quality often
signiﬁcantly diverges from the average. This issue
is discussed in depth in (Reichart et al., 2010b).
Our algorithm is deterministic3 .
For German, in the k=26 scenario our algorithm
outperforms Clark’s, often outperforming even its
maximum in 100 runs. In the k=17 scenario, our
algorithm obtains a higher score than Clark with
probability 0.4 to 0.78, depending on the measure
and scenario. Clark’s average score is slightly better in the Many-to-1 measure, while our algorithm
performs somewhat better than Clark’s average in
the 1-to-1 and NVI measures.
The DeWAC corpus from which we extracted
statistics for the German experiments is out of domain with respect to NEGRA. The corresponding corpus in English, NANC, is a newswire corpus and therefore clearly in-domain with respect
to WSJ. This is reﬂected by the percentage of unknown words, which was much higher in German
than in English (8.1% and 1.6%), lowering results.
Table 2 shows the effect of each of our algorithm’s components. Each component provides
an improvement over the base distributional algorithm. The full coordinate clustering stage (several iterations, F) considerably improves the score
over a single iteration (F(I=1)). Capitalization information increases the score more than the morphological information, which might stem from
the granularity of the POS tag set with respect to
names. This analysis is supported by similar experiments we made in the ‘Coarse k=13’ scenario
(not shown in tables here). There, the decrease in
performance was only of 1%–2% in the mapping
3
The ﬂuctuations inﬂicted on our algorithm by the random
mapping of unknown words are of less than 0.1% .

1304

Van Gael
Prototype

Excluding Punctuation
M-to-1 1-to-1
NVI
V
59.1
48.4
0.999 0.530
67.5
58.8
0.809 0.608

Including Punctuation
M-to-1 1-to-1
NVI
V
62.3
51.3
0.861 0.591
71.6
63.5
0.663 0.677

M-to-1
64.0
71.6

Perfect Punctuation
1-to-1
NVI
V
54.6
0.820 0.610
63.9
0.659 0.679

Table 3: Comparison between the iHMM: PY-ﬁxed model (Van Gael et al., 2009) and ours with various punctuation assignment schemes. Left section: punctuation tokens are excluded. Middle section: punctuation tokens are included. Right section:
perfect assignment of punctuation is assumed.

based measures and 3.5% in the V measure.
Finally, Table 4 presents reported results for all
recent algorithms we are aware of that tackled the
task of unsupervised POS induction from plain
text. Results for our algorithm’s and Clark’s are
reported for the ‘Fine, k=34’ scenario. The settings of the various experiments vary in terms of
the exact annotation scheme used (coarse or ﬁne
grained) and the size of the test set. However, the
score differences are sufﬁciently large to justify
the claim that our algorithm is currently the best
performing algorithm on the PTB-WSJ corpus for
POS induction from plain text4 .
Since previous works provided results only for
the scenario in which punctuation is included, the
reported results are not directly comparable. In
order to quantify the effect various punctuation
schemes have on the results, we evaluated the
‘iHMM: PY-ﬁxed’ model (Van Gael et al., 2009)
and ours when punctuation is excluded, included
or perfectly tagged5 . The results (Table 3) indicate that most probably even after an appropriate
correction for punctuation, our model remains the
best performing one.

8

Discussion

In this work we presented a novel unsupervised algorithm for POS induction from plain text. The algorithm ﬁrst generates relatively accurate clusters
of high frequency words, which are subsequently
used to bootstrap the entire clustering. The distributional and morphological representations that
we use are novel for this task.
We experimented on two languages with mapping and information theoretic clustering evaluation measures. Our algorithm obtains the best reported results on the English PTB-WSJ corpus. In
addition, our results are almost always better than
Clark’s on the German NEGRA corpus.
4

Graca et al. (2009) report very good results for 17 tags in
¸
the M-1 measure. However, their 1-1 results are quite poor,
and results for the common IT measures were not reported.
Their results for 45 tags are considerably lower.
5
We thank the authors for sending us their data.

We have also performed a manual error analysis, which showed that our algorithm performs
much better on closed classes than on open
classes. In order to asses this quantitatively, let
us deﬁne a random variable for each of the gold
clusters, which receives a value corresponding to
each induced cluster with probability proportional
to their intersection size. For each gold cluster,
we compute the entropy of this variable. In addition, we greedily map each induced cluster to a
gold cluster and compute the ratio between their
intersection size and the size of the gold cluster
(mapping accuracy).
We experimented in the ‘Fine k=34’ scenario.
The clusters that obtained the best scores were
(brackets indicate mapping accuracy and entropy
for each of these clusters) coordinating conjunctions (95%, 0.32), prepositions (94%, 0.32), determiners (94%, 0.44) and modals (93%, 0.45).
These are all closed classes.
The classes on which our algorithm performed
worst consist of open classes, mostly verb types:
past tense verbs (47%, 2.2), past participle verbs
(44%, 2.32) and the morphologically unmarked
non-3rd person singular present verbs (32%, 2.86).
Another class with low performance is the proper
nouns (37%, 2.9). The errors there are mostly
of three types: confusions between common and
proper nouns (sometimes due to ambiguity), unknown words which were put in the unknown
words cluster, and abbreviations which were given
a separate class by our algorithm. Finally, the algorithm’s performance on the heterogeneous adverbs class (19%, 3.73) is the lowest.
Clark’s algorithm exhibits6 a similar pattern
with respect to open and closed classes. While
his algorithm performs considerably better on adverbs (15% mapping accuracy difference and 0.71
entropy difference), our algorithm scores considerably better on prepositions (17%, 0.77), superlative adjectives (38%, 1.37) and plural proper
names (45%, 1.26).
6
Using average mapping accuracy and entropy over the
100 runs.

1305

Naturally, this analysis might reﬂect the arbitrary nature of a manually design POS tag set
rather than deﬁciencies in automatic POS induction algorithms. In future work we intend to analyze the output of such algorithms in order to improve POS tag sets.
Our algorithm and Clark’s are monosemous
(i.e., they assign each word exactly one tag), while
most other algorithms are polysemous. In order to
assess the performance loss caused by the monosemous nature of our algorithm, we took the M-1
greedy mapping computed for the entire dataset
and used it to compute accuracy over the monosemous and polysemous words separately. Results
are reported for the English ‘Fine k=34’ scenario
(without punctuation). We deﬁne a word to be
monosemous if more than 95% of its tokens are
assigned the same gold standard tag. For English,
there are approximately 255K polysemous tokens
and 578K monosemous ones. As expected, our
algorithm is much more accurate on the monosemous tokens, achieving 76.6% accuracy, compared to 47.1% on the polysemous tokens.
The evaluation in this paper is done at the token
level. Type level evaluation, reﬂecting the algorithm’s ability to detect the set of possible POS
tags for each word type, is important as well. It
could be expected that a monosemous algorithm
such as ours would perform poorly in a type level
evaluation. In (Reichart et al., 2010a) we discuss
type level evaluation at depth and propose type
level evaluation measures applicable to the POS
induction problem. In that paper we compare the
performance of our Prototype Tagger with leading unsupervised POS tagging algorithms (Clark,
2003; Goldwater and Grifﬁths, 2007; Gao and
Johnson, 2008; Van Gael et al., 2009). Our algorithm obtained the best results in 4 of the 6
measures in a margin of 4–6%, and was second
best in the other two measures. Our results were
better than Clark’s (the only other monosemous
algorithm evaluated there) on all measures in a
margin of 5–21%. The fact that our monosemous algorithm was better than good polysemous
algorithms in a type level evaluation can be explained by the prototypical nature of the POS phenomenon (a longer discussion is given in (Reichart
et al., 2010a)). However, the quality upper bound
for monosemous algorithms is obviously much
lower than that for polysemous algorithms, and
we expect polysemous algorithms to outperform

monosemous algorithms in the future in both type
level and token level evaluations.
The skewed (Zipﬁan) distribution of POS class
frequencies in corpora is a problem for many POS
induction algorithms, which by default tend to induce a clustering having a balanced distribution.
Explicit modiﬁcations to these algorithms were introduced in order to bias their model to produce
such a distribution (see (Clark, 2003; Johnson,
2007; Reichart et al., 2010b)). An appealing property of our model is its ability to induce a skewed
distribution without being explicitly tuned to do
so, as seen in Figure 2.
Acknowledgements. We would like to thank
Yoav Seginer for his help with his parser.

References
Michele Banko and Robert C. Moore, 2004. Part of
Speech Tagging in Context. COLING ’04.
Marco Baroni, Silvia Bernardini, Adriano Ferraresi and
Eros Zanchetta, 2009. The WaCky Wide Web: A
Collection of Very Large Linguistically Processed
Web-Crawled Corpora. Language Resources and
Evaluation.
Chris Biemann,
2006.
Unsupervised Part-ofSpeech Tagging Employing Efﬁcient Graph Clustering. COLING-ACL ’06 Student Research Workshop.
Thorsten Brants, 1997. The NEGRA Export Format.
CLAUS Report, Saarland University.
Peter F. Brown, Vincent J. Della Pietra, Peter V. de
Souze, Jenifer C. Lai and Robert Mercer, 1992.
Class-Based N-Gram Models of Natural Language.
Computational Linguistics, 18(4):467–479.
Alexander Clark, 2003. Combining Distributional and
Morphological Information for Part of Speech Induction. EACL ’03.
Mathias Creutz and Krista Lagus, 2005. Inducing the
Morphological Lexicon of a Natural Language from
Unannotated Text. AKRR ’05.
Sajib Dasgupta and Vincent Ng,
2007. Unsupervised Part-of-Speech Acquisition for ResourceScarce Languages. EMNLP-CoNLL ’07.
Dayne Freitag, 2004. Toward Unsupervised WholeCorpus Tagging. COLING ’04.
Jianfeng Gao and Mark Johnson, 2008. A Comparison of Bayesian Estimators for Unsupervised Hidden Markov Model POS Taggers. EMNLP ’08.
Yoav Goldberg, Meni Adler and Michael Elhadad,
2008. EM Can Find Pretty Good HMM POSTaggers (When Given a Good Start). ACL ’08.

1306

John Goldsmith, 2001. Unsupervised Learning of the
Morphology of a Natural Language. Computational
Linguistics, 27(2):153–198.

Andrew Rosenberg and Julia Hirschberg, 2007. VMeasure: A Conditional Entropy-Based External
Cluster Evaluation Measure. EMNLP ’07.

Sharon Goldwater and Tom Grifﬁths, 2007. Fully
Bayesian Approach to Unsupervised Part-of-Speech
Tagging. ACL ’07.

Hinrich Sch¨ tze, 1995. Distributional part-of-speech
u
tagging. EACL ’95.

Jo˜ o Graca, Kuzman Ganchev, Ben Taskar and Frea
¸
nando Pereira, 2009. Posterior vs. Parameter Sparsity in Latent Variable Models. NIPS ’09.
David Graff, 1995. North American News Text Corpus. Linguistic Data Consortium. LDC95T21.
Aria Haghighi and Dan Klein, 2006. Prototype-driven
Learning for Sequence Labeling. HLT–NAACL ’06.
Anil K. Jain, Narasimha M. Murty and Patrick J. Flynn,
1999. Data Clustering: A Review. ACM Computing
Surveys 31(3):264–323.
Wenbin Jiang, Liang Huang and Qun Liu, 2009. Automatic Adaptation of Annotation Standards: Chinese Word Segmentation and POS Tagging – A Case
Study. ACL ’09.
Mark Johnson, 2007. Why Doesnt EM Find Good
HMM POS-Taggers? EMNLP-CoNLL ’07.

Yoav Seginer, 2007. Fast Unsupervised Incremental
Parsing. ACL ’07.
Noah A. Smith and Jason Eisner, 2005. Contrastive
Estimation: Training Log-Linear Models on Unlabeled Data. ACL ’05.
John R. Taylor, 2003. Linguistic Categorization: Prototypes in Linguistic Theory, Third Edition. Oxford
University Press.
Jurgen Van Gael, Andreas Vlachos and Zoubin Ghahramani, 2009. The Inﬁnite HMM for Unsupervised
POS Tagging. EMNLP ’09.
Qin Iris Wang and Dale Schuurmans, 2005. Improved Estimation for Unsupervised Part-of-Speech
Tagging. IEEE NLP–KE ’05.
Qiuye Zhao and Mitch Marcus, 2009. A Simple Unsupervised Learner for POS Disambiguation Rules
Given Only a Minimal Lexicon. EMNLP ’09.

Harold W. Kuhn, 1955. The Hungarian method for
the Assignment Problem. Naval Research Logistics
Quarterly, 2:83-97.
Marina Meila, 2007. Comparing Clustering – an Information Based Distance. Journal of Multivariate
Analysis, 98:873–895.
Bernard Merialdo, 1994. Tagging English Text with
a Probabilistic Model. Computational Linguistics,
20(2):155–172.
James Munkres, 1957. Algorithms for the Assignment
and Transportation Problems. Journal of the SIAM,
5(1):32–38.
Sujith Ravi and Kevin Knight, 2009. Minimized Models for Unsupervised Part-of-Speech Tagging. ACL
’09.
Roi Reichart and Ari Rappoport, 2008. Unsupervised
Induction of Labeled Parse Trees by Clustering with
Syntactic Features. COLING ’08.
Roi Reichart and Ari Rappoport, 2009. The NVI Clustering Evaluation Measure. CoNLL ’09.
Roi Reichart, Omri Abend and Ari Rappoport, 2010a.
Type Level Clustering Evaluation: New Measures
and a POS Induction Case Study. CoNLL ’10.
Roi Reichart, Raanan Fattal and Ari Rappoport, 2010b.
Improved Unsupervised POS Induction Using Intrinsic Clustering Quality and a Zipﬁan Constraint.
CoNLL ’10.

1307

