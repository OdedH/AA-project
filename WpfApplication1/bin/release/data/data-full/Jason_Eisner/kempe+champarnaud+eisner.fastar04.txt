Appeared in Loek Cleophas and Bruce Watson (eds.), Proceedings of the
Eindhoven FASTAR Days (Comp. Sci. Tech. Report 04-40). Dept. of
Mathematics and Comp. Sci., Technische Universiteit Eindhoven, Dec. 2004.

A Note on Join and Auto-Intersection of n-ary Rational Relations
Andre Kempe1

Jean-Marc Champarnaud2

Jason Eisner3

1

Xerox Research Centre Europe – Grenoble Laboratory
6 chemin de Maupertuis – 38240 Meylan – France
Andre.Kempe@xrce.xerox.com – http://www.xrce.xerox.com
2

Universit´ de Rouen Facult´ des Sciences et des Techniques
e
e
76821 Mont-Saint-Aignan – France
Jean-Marc.Champarnaud@univ-rouen.fr

3

Johns Hopkins University – Computer Science Department
3400 N. Charles St. – Baltimore, MD 21218 — United States
jason@cs.jhu.edu – http://www.cs.jhu.edu/∼jason/

Abstract
A ﬁnite-state machine with n tapes describes a rational (or regular) relation on n strings. It is
more expressive than a relational database table with n columns, which can only describe a ﬁnite
relation.
We describe some basic operations on n-ary rational relations and propose notation for them. (For
generality we give the semiring-weighted case in which each tuple has a weight.) Unfortunately, the
join operation is problematic: if two rational relations are joined on more than one tape, it can lead
to non-rational relations with undecidable properties. We recast join in terms of “auto-intersection”
and illustrate some cases in which difﬁculties arise. We close with the hope that partial or restricted
algorithms may be found that are still powerful enough to have practical use.

1

Introduction

Multi-tape ﬁnite-state machines (FSMs) (Rabin and Scott, 1959; Elgot and Mezei, 1965; Kay, 1987;
Kaplan and Kay, 1994) are a natural generalization of the familiar one- and two-tape cases, known
respectively as ﬁnite-state acceptors and transducers.
An n-tape FSM characterizes n-tuples of strings. The set of tuples that it accepts is called an n-ary
relation. If the FSM is weighted, it deﬁnes a weighted n-ary relation that assigns each n-tuple a weight
(in some semiring), such as a probability.
The relations deﬁned by FSMs are known as rational (or regular) relations. Our interest in ntuples stems from our view of these relations as relational databases. In the familiar case n = 2, a
ﬁnite-state transducer can be regarded as a kind of (weighted) database of string pairs—for example,
spelling, pronunciation , French word, English word , or parent concept, child concept . An acyclic
transducer can represent any ﬁnite database of this sort. Shared substrings can make the representation
particularly efﬁcient: a hypothesis lattice for speech processing (Mohri, 1997) represents exponentially
many pairs in linear space.

Unlike a classical database, a transducer may even deﬁne inﬁnitely many pairs. For example, it
may characterize the pattern of the spelling-pronunciation relationship in such a way that it can map
even a novel word’s spelling to zero or more possible pronunciations (with various weights), and viceversa. Another transducer may attempt to map not just a word but a sentence of unbounded length to an
annotated, corrected, or translated version.
On this database view, it is natural to consider relations with more than 2 columns. In natural language processing, multi-tape machines have recently been used to represent lattices of speech, gesture,
interpretation triples for processing multimodal input (Bangalore and Johnston, 2000). They have also
been used in the morphological analysis of Semitic languages, using multiple tapes to synchronize the
vowels, consonants, and templatic pattern into a surface form (Kay, 1987; Kiraz, 2000). They may
be similarly useful for coordinating the multiple tiers of autosegmental phonology or articulator-based
speech recognition (Livescu, Glass, and Bilmes, 2003).
Unfortunately, one pays a price for allowing inﬁnite multi-column databases. Finite-state methods
derive their power from a rational algebra, which can combine simple FSMs using operations such as
union, closure, and composition. Databases similarly derive their power from a relational algebra. Cyclic
FSMs are closed under the rational operations, but not under the relational operations, as ﬁnite databases
are. For example, transducers are not closed under intersection (Rabin and Scott, 1959).
In this paper, we give a formal discussion of semiring-weighted n-ary relations (Section 2). We
deﬁne several useful operators (Section 3), offering useful notation and taking care to distinguish cases
that preserve the rationality of relations from those that do not.
The focus of the paper is a database join operator 1 that generalizes intersection, composition, and
cross product (Section 3.3). Certain cases of join (single-tape or ﬁnite) are guaranteed to preserve rationality and appear practically useful.
In Section 3.4, we reduce the join problem to a somewhat simpler problem of “auto-intersection”
(Kempe, Guingne, and Nicart, 2004). In Section 4, we illustrate how auto-intersecting two tapes of
a rational relation may produce a variety of non-rational weighted or unweighted relations, including
context-sensitive languages whose emptiness is undecidable. We leave open the possibility that there
may exist a partial or approximate algorithm with enough coverage to have some practical use.

2

Deﬁnitions

After recalling the basic deﬁnitions of a monoid and a semiring, we deﬁne n-ary weighted relations
and n-tape weighted ﬁnite-state machines. Our deﬁnitions follow the usual deﬁnitions for multi-tape
ﬁnite-state automata (Elgot and Mezei, 1965; Eilenberg, 1974), with semiring weights added just as for
acceptors and transducers (Kuich and Salomaa, 1986; Mohri, Pereira, and Riley, 1998).

2.1

Semirings

A monoid is a structure M, ◦, ¯ consisting of a set M , an associative binary operation ◦ on M , and
1
¯ such that ¯ ◦ a = a ◦ ¯ = a for all a ∈ M . A monoid is called commutative iff
a neutral element 1
1
1
a ◦ b = b ◦ a for all a, b ∈ M .
A semiring is a structure K = K, ⊕, ⊗, ¯ ¯ consisting of a set K, two binary operations, ⊕ (col0, 1
lection) and ⊗ (extension), and two neutral elements, ¯ and ¯ that satisﬁes the following properties:
0
1,
¯ is a commutative monoid
• K, ⊕, 0
• K, ⊗, ¯ is a monoid
1
• extension is left- and right-distributive over collection:
a ⊗ (b ⊕ c) = (a ⊗ b) ⊕ (a ⊗ c) , (a ⊕ b) ⊗ c = (a ⊗ c) ⊕ (b ⊗ c) , ∀a, b, c ∈ K

• ¯ is an annihilator for extension: ¯ ⊗ a = a ⊗ ¯ = ¯ , ∀a ∈ K
0
0
0 0
Examples of semirings are:
1. {FALSE, TRUE}, ∨, ∧, FALSE, TRUE : the boolean semiring, which can be used to deﬁne unweighted relations and machines.
2. N, +, ×, 0, 1 : a non-negative integer semiring.
3. R≥0 , +, ×, 0, 1 : a non-negative real semiring that can be used to model probabilities.
4. R≥0 ∪ {∞}, min, +, ∞, 0 : a “tropical” semiring, sometimes used to model negative logarithms
of probabilities.
∗

5. 2Σ , ∪, ·, ∅, {ε} : the semiring of unweighted languages over an alphabet Σ under union ∪ and
pairwise concatenation ·. Note that this has a subsemiring consisting of only the regular languages.
(Similar semirings exist whose elements are weighted languages and relations, but we do not deﬁne
them here.)
A semiring can have additional properties, and in this article we are interested in the following two:
1. commutativity: a ⊗ b = b ⊗ a , ∀a, b ∈ K
2. idempotency: a ⊕ a = a , ∀a ∈ K
All examples above are commutative, except the last one, which is commutative only if |Σ| = 1. Examples 1, 4, and 5 are idempotent.
We will use the following notations for repeated collection and extension of a single value k ∈ K:
ik = k ⊕ k ⊕ · · · ⊕ k
k

i

= k ⊗ k ⊗ ··· ⊗ k

(i times)

(1)

(i times)

(2)

Note that ik does not in general mean i ⊗ k. Usually the latter is not even deﬁned, as the integer i ∈ N
is usually not an element of the semiring.

2.2

Weighted n-ary Relations and Multi-Tape Weighted Finite-State Machines

A weighted n-ary relation is a function from (Σ∗ )n to K, for a given ﬁnite alphabet Σ and a given weight
semiring K = K, ⊕, ⊗, ¯ ¯ . In other words, the relation assigns a weight to any n-tuple of strings. A
0, 1
weight of ¯ can be interpreted as meaning that the tuple is not in the relation.
0
We are especially interested in rational (or regular) n-ary relations—that is, relations that can be
encoded by n-tape weighted ﬁnite-state machines, which we now deﬁne.
We adopt a convention that variable names referring to n-tuples of strings include a superscript (n) .
Thus we write s(n) rather than s for a tuple of strings s1 , . . . , sn . We also use this convention for
the names of more complex objects that contain n-tuples of strings, such as n-tape automata and their
transitions and paths.
An n-tape weighted ﬁnite-state machine (WFSM or n-WFSM),1 A(n) , is deﬁned by a six-tuple
A(n) = Σ, Q, K, E (n) , λ,

(3)

with Σ being a ﬁnite alphabet, Q a ﬁnite set of states, K = K, ⊕, ⊗, ¯ ¯ the semiring of weights,
0, 1
E (n) ⊆ (Q × (Σ∗ )n × K × Q) a ﬁnite set of weighted n-tape transitions, λ : Q → K a function that
assigns initial weights to states, and : Q → K a function that assigns ﬁnal weights to states.
1

We follow some recent literature in using the term “machine” rather than “automaton.” The acronym to refer to the general
n-tape case is then FSM or n-FSM, which leaves the acronym FSA available to refer to the special case of a ﬁnite-state acceptor
(n = 1). FST refers to the special case of a ﬁnite-state transducer (n = 2).

Any transition e(n) ∈ E (n) has the form
e(n) = p,

(n)

, w, n

(4)

We refer to these four components as the transition’s source state p(e(n) ) ∈ Q, its label (e(n) ) ∈ (Σ∗ )n ,
its weight w(e(n) ) ∈ K, and its target state n(e(n) ) ∈ Q.
(n) (n)
(n)
(n)
(n)
A path γ (n) of length ≥ 0 is a sequence of transitions e1 e2 · · · e such that n(ei ) = p(ei+1 )
for each i ∈ [[1, −1]]. A path’s label is deﬁned to be the elementwise concatenation of the labels of its
transitions:
def
(n)
(n)
(n)
(γ (n) ) = (e1 ) · (e2 ) · · · · · (e )
(5)
This is an n-tuple of strings having the form s(n) = s1 , s2 , . . . , sn . The path’s weight is deﬁned to be

def

(n)

w(γ (n) ) = λ(p(e1 )) ⊗ 


(n)

w ej

 ⊗ (n e(n) )

(6)

j∈[[1, ]]

¯
The path is said to be successful, and to accept its label, if w(γ (n) ) = 0. We denote by ΓA(n) the set of
(n) , and by Γ
(n) ) the set of successful paths (if any) that accept s(n) :
all successful paths of A
A(n) (s
ΓA(n) (s(n) ) = { γ (n) ∈ ΓA(n) | s(n) = (γ (n) ) }

(7)

Now, the machine A(n) deﬁnes a weighted n-ary relation R(A(n) ) : (Σ∗ )n → K that assigns to each
n-tuple, s(n) , the total weight of all paths accepting it:
def

RA(n) (s(n) ) =

w(γ (n) )

(8)

γ (n) ∈ΓA(n) (s(n) )

It is convenient to deﬁne the support of an arbitrary weighted relation R(n) , meaning the set of tuples
to which the relation gives non-¯ weight:
0
support(R(n) ) = { s(n) ∈ (Σ∗ )n | R(n) (s(n) ) = ¯ }
0
def

(9)

This support set can be regarded as an ordinary unweighted relation obtained from R(n) . A different
perspective on unweighted relations is that they are weighted relations over the boolean semiring, i.e.,
functions from (Σ∗ )n → {FALSE, TRUE}.

2.3

Inﬁnite Sums

In deﬁning R(A(n) ), we glossed over one point for simplicity’s sake. A sum over ﬁnitely many weights
can be computed by repeated application of ⊕. But (8) may sometimes call for an inﬁnite sum, whose
meaning has not been deﬁned. This case arises if RA(n) contains any cyclic paths with the label
, , . . . . Cyclic paths of this sort cannot simply be disallowed in a natural way, since they can be
re-introduced by the closure and projection operations discussed below.
Brieﬂy, the solution is to pre-compute the geometric sum k ∗ =

∞

i=0

k i ∈ K for each k ∈ K.2

In practice, one simply deﬁnes a closure operator ∗ that satisﬁes certain axioms, obtaining a so-called
closed semiring.
This allows inﬁnite sums over any regular set of paths, as required by (8) and by section 3’s equations (11), (12), (13), and (21). One constructs a WFSM containing just those paths (e.g., ΓA(n) (s(n) )),
and then sums their weights with an algorithm that generalizes the Kleene-Floyd-Warshall technique to
closed semirings (Lehmann, 1977).
2

Divergent sums can be represented by k∗ = ∞, where ∞ ∈ K is a distinguished value.

3

Operations

We now describe some central operations on n-ary weighted relations and their n-tape WFSMs, focusing
on operations that affect the number of tapes. (See (Kempe, Guingne, and Nicart, 2004).) In particular,
we introduce an “auto-intersection” operation that will simplify the discussion of multi-tape join.
Our notation is chosen throughout to highlight the connection to relational databases.

3.1

Simple Operations

The basic rational operations of union, concatenation, and closure can be used to construct any n-ary
weighted rational relation.3 Thus, the rational operations can be used to write regular expressions that
specify particular relations. On the database perspective, such expressions are useful for specifying both
actual databases (typically ﬁnite relations) and particular queries (typically inﬁnite relations, i.e., the set
of all tuples with a given property). (Section 3.3 will discuss how to intersect a database with a query.)
(n)
(n)
(n)
The union and concatenation of two weighted n-ary relations, R1 and R2 , are the relations R1 ∪
(n)
(n)
(n)
R2 and R1 · R2 deﬁned by
(n)

(n)

(s(n) )

=

(n)

(s(n) )

=

R1 ∪ R2
(n)

R1 · R2

def

(n)

(n)

R1 (s(n) ) ⊕ R2 (s(n) )

(10)

(n)

def

(n)

R1 (u(n) ) ⊗ R2 (v (n) )

(11)

u(n) ,v (n) :
(∀i∈[[1,n]])si =ui ·vi

The closure of R(n) is the relation
∞

(R

(n) ∗

)

def

R(n) · R(n) · · · R(n) , implying that

=
=0

times

∞

(R(n) )∗ ( s1 , . . . , sn )

(n)

R(n) (uj )

=
=0

(n)
(n)
u1 ,...u :
(∀i∈[[1,n]])si =(u1 )i ·(u2 )i ···(u

(12)

j=1
)i

These operations can be implemented by simple constructions on the corresponding nondeterministic
n-tape WFSMs (Rosenberg, 1964). These n-tape constructions and their semiring-weighted versions are
exactly the same as for acceptors (n = 1) and transducers (n = 2), as they are indifferent to the n-tuple
transition labels.

3.2

Projection and Complementary Projection

Projection keeps certain columns of a database relation and discards the others. In the case of a rational
relation implemented by a n-WFSM, it can be implemented by discarding the corresponding tapes of the
n-WFSM, yielding an m-WFSM for m < n.
Projection may map several distinct n-tuples onto the same m-tuple. In this case, we will deﬁne the
weight of the m-tuple by summing the several n-tuples’ weights using ⊕. This resembles aggregation
in databases, but note that only weights can be aggregated across n-tuples, not the (string) data in the
n-tuples themselves.
3
By combining the “atomic” weighted relations, namely, those whose support is a single tuple from the ﬁnite set
{(s1 , s2 , . . . sn ) : |s1 s2 · · · sn | ≤ 1}.

For any j1 , . . . , jm ∈ [[1, n]], we formally deﬁne a projection operator π
relations to m-ary relations:

π

(n)

j1 ,...,jm

(R1 ) (s(m) )

(n)

def

j1 ,...,jm

R1 (u(n) )

=

that maps n-ary

(13)

u(n) :

(∀i∈[[1,m]]) si=uji

It retains only those component strings (i.e. tapes) of each tuple that are speciﬁed by the indices j1 , . . . jm ,
and places them in the speciﬁed order.
Notice that our deﬁnition allows projection indices to occur in any order, possibly with repeats. Thus
the tapes of s(n) can be permuted or duplicated. For example, π 2,1 will invert a 2-ary relation.
As a convenience, we also deﬁne the complementary projection of a relation. For any j1 , . . . jm ∈
[[1, n]], we deﬁne an operator π {j1 ,...jm } that removes the tapes j1 , . . . jm and preserves all other tapes
in their original order. Without loss of generality we may assume that j1 < j2 < · · · < jm ; then
we can deﬁne π {j1 ,...jm } as equivalent to π 1,...,j1 −1,j1 +1,...jm −1,jm +1,...n , which maps n-ary relations to
(n − m)-ary relations.

3.3

Join and Generalized Composition

Applications: Our version of the join operation is quite powerful. It can be used to join two “databases”
(typically ﬁnite relations), to conjoin two “queries” (typically inﬁnite relations), or to select those database tuples that match a query, reweighting them if the query is weighted.
Another family of uses is inspired by natural language processing, where WFSTs (n = 2) are commonly used to construct noisy channel models (Knight and Graehl, 1998). Using n > 2 tapes allows us to
generalize naturally to doing constraint programming or graphical modeling over string-valued variables.
Given variables V1 , . . . Vn with unknown values in the inﬁnite domain Σ∗ , one can specify a (weighted)
m-ary relation to express a (soft) constraint over some m ≤ n of the variables. All known constraint
relations can be systematically joined together, along tapes that correspond to common variables. This
yields a (weighted) n-ary relation that evaluates which n-tuples are appropriate as joint values of the n
variables. If this n-ary relation speciﬁes a probability distribution over n-tuples, one can intersect it with
another n-ary relation describing incomplete data, in order to compute the probability of the data for
purposes of parameter training or statistical inference.
As we will see, join is too powerful: rational relations are not closed under arbitrary joins. Section 4
will explore this point in detail. Nonetheless, we can mathematically deﬁne the possibly non-rational
result of a join. The operation appears so useful that it would be helpful to have a partial or approximate
algorithm.
Deﬁnition: The reader may already be familiar with the notion of natural join on databases. Our
presentation differs from the standard database treatment in that our tapes are numbered, whereas the
columns of a database are typically named. So our join operators, unlike a database join, must explicitly
select tapes by number, and as a result are neither associative nor commutative.
A join of two relations is formed by ﬁnding “matching” pairs of tuples. For example, abc, def,
and def, ghi, , jkl match on two of their tapes. We notate the matching of tapes in this case as
{2 = 1, 3 = 3}. They combine to yield a tuple abc, def, , ghi, jkl , whose weight in the joined relation
is the product (under ⊗) of the two original tuples’ weights.
More precisely, for any distinct i1 , . . . ir ∈ [[1, n]] and any distinct j1 , . . . jr ∈ [[1, m]], we deﬁne a join
operator 1{i1 =j1 ,...,ir =jr } . It combines an n-ary and an m-ary relation into an (n + m − r)-ary relation
deﬁned as follows:

(n)

R1

(m)

1{i1 =j1 ,...,ir =jr } R2

(n)

def

(m)

( u1 , . . . , un , s1 , . . . , sm−r ) = R1 (u(n) ) ⊗ R2 (v (m) )

(14)

where v (m) is the unique tuple such that π {j1 ,...jr } (v (m) ) = s(m−r) and (∀ ∈ [[1, r]])vj = ui .
Relation to Cross Product: Taking r = 0 gives an important special case. The cross product operator
×, equivalent to 1∅ , combines an n-ary and an m-ary relation into an (n + m)-ary relation:
(n)

(m)

(n)

def

R1 × R2

= R1

(m)

1∅ R 2

(15)

with the result that
(n)

(m)

(n)

(n)

(m)

( u1 , . . . , un , v1 , . . . , vm ) = R1 (u(n) ) ⊗ R2 (v (m) )

R1 × R2
(m)

(n)

(16)

(m)

A WFSM for R1 × R2 can easily be constructed from WFSMs for R1 and R2 , by concatenating
them after appropriately “padding” their transition labels into (n + m)-tuples via extra epsilons. Thus,
the cross product of weighted rational relations is always rational.
Relation to Intersection: Taking n = r = m gives another important special case. The intersection of
two n-ary relations is another n-ary relation:
(n)

(n)

= R1

(n)

(n)

(s(n) ) = R1 (s(n) ) ⊗ R2 (s(n) )

R1 ∩ R2
with the result that

R1 ∩ R2

def

(n)

(n)

1{1=1,2=2,...n=n} R2
(n)

(17)

(n)

(18)

It is known that the intersection of transducers (n = 2) is not necessarily rational (Rabin and Scott,
1959): { aj b∗ , cj | j ∈ N} ∩ { a∗ bj , cj | j ∈ N} = { aj bj , cj | j ∈ N}. Nor, for that matter, is
intersection of acceptors (n = 1) if they are weighted by a non-commutative semiring. Thus rational
relations are not closed under the more general join operation, either.
Generalized Composition: For distinct i1 , . . . ir ∈ [[1, n]] and distinct j1 , . . . jr ∈ [[1, m]], it is convenient
to deﬁne a generalized composition operator {i1 =j1 ,...,ir =jr } . It carries out a join and then discards the
joined tapes:
(n)

R1

(m)

{i1 =j1 ,...,ir =jr }

R2

(n)

def

= π {i1 ,...ir } R1

(m)

1{i1 =j1 ,...,ir =jr } R2

(19)

Note that
can result in aggregation because it uses π . For example, the special case of ordinary
¯
composition ◦ of transducers
(2)

(2)

R1 ◦ R 2

(2)

def

= R1

(2)

{2=1}

R2

(2)

(2)

= π {2} (R1 1{2=1} R2 )

(20)

results in a summation over strings v on the discarded tape that was joined:
(2)

(2)

R1 ◦ R 2

(2)

(2)

R1 (u, v) ⊗ R2 (v, w)

(u, w) =

(21)

v

The generalized composition of rational relations is not necessarily rational.
Single-Tape Join: We speak about single-tape join if only one tape is used in each relation (r = 1). Two
well-known special cases are the join 1{1=1} used to intersect two acceptors in (17) (where n = 1), and
the join 1{2=1} used during classical composition of two transducers in (20).

There are other uses of single-tape join. A composition cascade of several transducers, R(2) =
(2)
(2)
(2)
(2)
(2)
(2)
R1 ◦ R2 ◦ R3 , could be replaced by a join cascade, R(4) = R1 1{2=1} R2 1{2=1} R3 . The
intermediate results are now preserved on tapes 2 and 3 for subsequent inspection or further transduction
(Kempe, 2004). In this way, single-tape join is adequate to combine several transducers into any tree
(2)
(2)
(2)
topology: R(4) = R1 1{2=1} R2
1{2=1} R3 . One can use this technique to implement a
tree-structured directed graphical model (sometimes called a dendroid distribution) by joining weighted
transducers that represent the conditional probability distributions of the model.
Sometimes one wishes to join an n-ary relation with a cross product of m languages. This operation
can be regarded as m single-tape joins. It can be used to train the parameters of the dendroid distribution
described above, as explained for n = m = 2 by (Eisner, 2002). The generalization to more tapes
is particularly useful for training a cascaded noisy channel model when intermediate results along the
channel are partly observed.
The single-tape join of weighted multi-tape rational relations is rational as long as the weights fall in
a commutative weight semiring. One can construct a WFSM for the resulting relation, using a standard
“cross-product of states” construction.
The commutativity of the weights is crucial to this construction. (The constructed WFSM’s paths
interleave weights from paths in the two input WFSMs.) No such construction is possible if the weight
semiring K is not commutative. For example, let k, k be weights that do not commute. Let R(1) be a
rational language such that ∀j ∈ N, R(1) (aj ) = k j ⊗k . Then (18) implies that ∀j, R(1) ∩ R(1) (aj ) =
k j ⊗ k ⊗ k j ⊗ k ; this single-tape join cannot in general be computed by any WFSM.
Mohri, Pereira, and Riley (1998), writing about WFST composition, noted another subtlety in extending the “cross product of states” construction to weighted machines. Their observation and solution
apply generally to single-tape join of WFSMs (and would presumably be relevant to any partial algorithm
for multi-tape join). A pair of successful paths in the input machines are considered to “match” if they
both accept the same string s on the single tape being joined. A pair of matched input paths is supposed
to yield exactly one path in the composed machine. However, if both input paths allow transitions on
the join tape at the same position in s, then a naive implementation of the construction may produce
i > 1 identically labeled and weighted paths, corresponding to different alignments of the input paths.
This “path multiplicity problem” will incorrectly contribute i copies of the path weight to the sum in (8),
affecting the result unless the weight semiring is idempotent. The solution is to revise the construction
to allow only a canonical alignment of matched input paths.

3.4

Auto-Intersection

Our discussion of join will be simpliﬁed by reducing it to a simpler problem. For any distinct i1 , j1 , . . .
ir , jr ∈ [[1, n]], we deﬁne an auto-intersection operator σ{i1 =j1 ,i2 =j2 ,...,ir =jr } that maps a relation R(n)
to a “subset” of that relation, preserving tuples s(n) whose elements are equal in pairs as speciﬁed, but
removing all other tuples from the support of the relation.4

σ{i1 =j1 ,...,ir =jr } (R(n) ) ( s1 , . . . , sn )

def

=

R(n) ( s1 , . . . , sn ) if (∀ ∈ [[1, r]])si = sj
(22)
¯
0
otherwise

Auto-intersection does not necessarily preserve the rationality of R(n) , as we will discuss in Section 4.
4

The requirement that the 2r indices be distinct mirrors the similar requirement on join and is needed in (26).
But it can be evaded by duplicating tapes: an illegal auto-intersection such as σ{1=2,2=3} (R) can be computed as
π {3} (σ{1=2,3=4} (π 1,2,2,3 (R))).

Note that auto-intersecting a relation is different from joining the relation with its own projections.
For example, σ{1=2} (R(2) ) is supported by tuples of the form w, w ∈ R(2) . By contrast, R(2) 1{1=1}
π 2 (R(2) ) is supported by tuples w, x ∈ R(2) such that w can also appear on tape 2 of R(2) (but not
necessarily paired with a copy of w on tape 1).
An example of auto-intersection is shown in Figure 1. It encodes the relation
(3)

R1

(3)
σ{1=3} (R1 )

0

a, x, ε
1

b, y, a
1

∗

a:x: ε

1

ε, z, b

= { abj , xy j z, aj b | j ∈ N }

(23)

1

= { ab , xy z, a b }
b:y:a

(3)

Α1
(a)

=

ε :z:b

(24)
(3)

Α
2

(b)

0

a:x: ε

b:y:a

1

(3)

2

ε :z:b

3

(3)

Figure 1: (a) A WFSM A1 and (b) its auto-intersection A(3) = σ{1=3} (A1 ). (Weights omitted)
It is possible to reduce join to auto-intersection using only rational operations (namely cross product
and complementary projection). An arbitrary join can be implemented as
(n)

R1

(m)

1{i1 =j1 ,...,ir =jr } R2

= π {n+j1 ,...,n+jr }

(n)

(m)

σ{i1 =n+j1 ,...,ir =n+jr } ( R1 ×R2

)

(25)

Conversely, it is possible to reduce any auto-intersection to a single join with a rational relation:



σ{i1 =j1 ,...,ir =jr } (R(n) ) = R(n) 1{i1 =1,j1 =2,...,ir =2r−1,jr =2r} (π

1,1

(Σ∗ )×· · ·×π

1,1


(Σ∗ ) (26)

r times

Thus, for any class of “difﬁcult” join instances whose results are non-rational or have undecidable
emptiness (see section 4.4), there is a corresponding class of difﬁcult auto-intersection instances, and
vice-versa. Conversely, a partial solution to one problem would yield a partial solution to the other. In
future work we hope to identify such a partial algorithm for auto-intersection.
The rest of this paper is therefore devoted to remarks on the auto-intersection problem only. Working
in terms of auto-intersection rather than join will simplify our discussion. First, only one machine is
involved. Second, in considering partial algorithms for auto-intersection, we do not have to worry about
the order in which non-commutative weights from two joined machines are multiplied together, or the
path multiplicity problem. Those issues have already been handled in the cross-product step of the join
construction (25), and are not of further concern to the auto-intersection step.
For simplicity, we will focus on auto-intersections σ{i=j} that involve only a single pair of tapes. That
is enough to expose the core difﬁculties. Indeed, the general case of auto-intersection can be deﬁned in
terms of this simple case:
def

σ{i1 =j1 ,...,ir =jr } ( R(n) ) = σ{ir =jr } ( · · · σ{i1 =j1 } ( R(n) ) · · · )

(27)

Nonetheless, we caution that the general case might beneﬁt from a more direct treatment. It may be wise
to compute σ{i1 =j1 ,...,ir =jr } “all at once” rather than one tape pair at a time. The reason is that even when
σ{i1 =j1 ,...,ir =jr } is rational, a ﬁnite-state strategy for computing it via (27) could “fail” by encountering
non-rational intermediate results. For example, consider applying σ{2=3,4=5} to the rational 5-ary relation { ai bj , ci , cj , x, y | i, j ∈ N}. The ﬁnal result is rational (the empty relation), but the intermediate
result after applying just σ{2=3} would be the non-rational relation { ai bi , ci , ci , x, y | i ∈ N}.

4

Some Difﬁcult Examples for Auto-Intersection

Some instances of auto-intersection are “easy.” In particular, consider a ﬁnite relation (one with ﬁnite
support, representable by an acyclic WFSM). Its auto-intersection is computable and is itself ﬁnite, since
it just selects some tuples of the original relation. (Thus, by (25), R1 1 R2 is ﬁnite if R1 or R2 is.) On
such “easy” examples, the job of a good auto-intersection algorithm is merely to keep the resulting FSM
small by preserving the sharing of substrings in the original FSM.
In this section, we will discuss some “difﬁcult” classes of auto-intersection problems, where the result
is non-rational or has undecidable properties. Each such class has a matching class of join problems, as
discussed in section 3.4.
These difﬁculties imply that there is no general ﬁnite-state join algorithm. Nor is there an algorithm
that produces the join whenever it is rational and returns an error code otherwise.
At the same time, the examples in this section may be instructive if one wishes to design a more
limited join or auto-intersection algorithm that can succeed (exactly or approximately) on some practical
cases. We leave such a task to future work.

4.1

Equal-Exponent Problem

Consider the unweighted binary relation R(2) = { ai bj , aj bk | i,j,k ∈ N}, interpreted as a weighted
relation over the boolean semiring. The relation is rational because it can be encoded by a 2-FSM
(Figure 2a). Its auto-intersection σ{1=2} (R(2) ) = { ai bi , ai bi | i ∈ N} is, however, non-rational. Notice
that the auto-intersection would in effect need to select just those paths in Figure 2a where all three cycles
are traversed the same number of times.
a: ε

(a)

0

ε:b

b:a

ε:ε

1

ε:ε

2

a: ε

(b)

0

ε:ε

b:a
ε:ε

1

ε:c

c:b
ε:ε

2

3

Figure 2: Two FSMs whose auto-intersection leads to equal-exponent problems

We can extend this example to any number of equal exponents. Consider for example the binary
relation R(2) = { ai bj ck , aj bk c | i,j,k, ∈ N}, which is rational (Figure 2b) but has a non-rational
auto-intersection σ{1=2} (R(2) ) = { ai bi ci , ai bi ci | i ∈ N}.
We say that such examples suffer from the equal-exponent problem. The equal-exponent problem may also appear on tapes other than the ones being intersected. The unweighted 3-ary relation
{ ai a, aaj , xi yz j | i, j ∈ N} is rational (Figure 3a); but its auto-intersection under σ{1=2} is equal to
{ ai a, aai , xi yz i | i ∈ N}, which is not rational because its projection onto tape 3 is not a regular language.
a:ε:x

(a)

0

a:a:y

1

ε:a:z

a:ε /w 0

(b)

0

a:a /w 1

1
/ρ1

ε:a /w 2

Figure 3: FSMs whose auto-intersection on tapes 1,2 requires equal exponents on tape 3 or in weights

Finally, the equal-exponent problem may appear in the weights assigned by the relation, if the weight
semiring is not commutative. Figure 3b is a variant of Figure 3a that replaces the third tape with weights.

Its auto-intersection under σ{1=2} is the weighted relation R deﬁned by
i
i
R( ai a, aai ) = w0 ⊗ w1 ⊗ w2 ⊗
R(s(2) ) = ¯ otherwise
0

(28)

1

(29)

This relation has rational support, but is not in general a rational relation. It does become rational if the
i
i
weight semiring is commutative, in which case w0 ⊗ w1 ⊗ w2 ⊗ 1 can be computed as (w0 ⊗ w2 )i ⊗
w1 ⊗ 1 . Notice that if the weights are rational languages over an alphabet Σ (see Section 2.1), so that
they effectively act like a third tape, then they are guaranteed to commute only if |Σ|=1.

4.2

Shufﬂe Problem

The shufﬂe product of two strings u
u

v

def

=

v is deﬁned, e.g., in (Sakarovitch, 2003) as:

{ u1 v1 . . . uj vj | u = u1 . . . uj , v = v1 . . . vj , (∀i ∈ [[1, j]])ui , vi ∈ Σ∗ }

(30)

This set contains all possible “interleavings” of the symbols from u and v. The symbols of u keep their
respective order, as do the symbols of v, but any order is allowed between a symbol from u and a symbol
from v. For example:
abc

xy = {abcxy, abxcy, abxyc, axbcy, axbyc, axybc, xabcy, xabyc, xaybc, xyabc} (31)

aa

xx = {aaxx, axax, axxa, xaax, xaxa, xxaa}

aaa

(32)

aaa = {aaaaaa}

(33)

The size of the set u
v grows exponentially in the lengths of u and v.
Consider the unweighted relation R(3) = { ai , aj , xi
y j | i, j ∈ N}, interpreted as a weighted
relation over the boolean semiring. It is rational because it can be encoded by a 3-FSM (Figure 4a). Its
auto-intersection σ{1=2} (R(3) ) = { ai , ai , xi
y i | i ∈ N} is, however, non-rational, as its projection
onto tape 3 is the non-rational language of strings having equal numbers of x’s and y’s.
a:ε:ε:ε:x
a: ε :x
0

(a)

0

ε: a: y

(b) ε:ε:ε:a:z

a: ε /w 0

ε: a:a:ε: y

(c)

0
/ρ0

ε: a /w 1

Figure 4: Three (W)FSMs whose auto-intersection leads to shufﬂe problems

Using additional tapes lets us extend this example to any number of equal exponents. For example,
the relation R(5) = { ai , aj , aj , ak , xi
yj
z k | i, j, k ∈ N} is rational (Figure 2b) but has a nonrational auto-intersection σ{1=2,3=4} (R(5) ) = { ai , ai , ai , ai , xi
yi
z i | i ∈ N}.
This shufﬂe problem can be regarded as the source of other failures of rationality. If R(1) is any
rational language, then the single-tape join { ai , aj , (xi
y j ) | i, j ∈ N} 1{3=1} R(1) is also rational.
Auto-intersecting it using the σ{1=2} operator yields a relation whose tape 3 recognizes a “restricted
shufﬂe,” namely, the potentially non-rational language {xi
y i | i ∈ N} ∩ R(1) . For example, taking
R(1) to be the language x∗ y ∗ creates the equal-exponent language {xi y i | i ∈ N} of section 4.1.
Beyond simply restricting the shufﬂe language, one can also transduce it to obtain further examples.
Consider the rational 3-relation { ai , aj , (xi
y j ) | i, j ∈ N} {3=1} R(2) , where R(2) is any rational

2-ary relation. Applying the σ{1=2} operator yields a relation whose tape 3 recognizes the transduction
of {xi
y i | i ∈ N} by R(2) . The transduction can replace xi and y i by arbitrary languages while
restricting their shufﬂing.
The shufﬂe problem may also appear in the weights assigned by the relation, if the weight semiring is
not both commutative and idempotent. Figure 4c is a variant of Figure 4a that replaces the third tape with
i
i
weights.5 Applying the σ{1=2} operator yields a relation R such that ∀i ∈ N, R(ai ) = (w0
w1 ) ⊗ 0 ,
i
i
where the informal notation w0 w1 denotes the “shufﬂe sum of two products of weights.” For example,
if k, l, p, q ∈ K, we would write
(k ⊗ l)

(p ⊗ q) = (k ⊗ l ⊗ p ⊗ q) ⊕ (k ⊗ p ⊗ l ⊗ q) ⊕ (k ⊗ p ⊗ q ⊗ l) ⊕
(p ⊗ k ⊗ l ⊗ q) ⊕ (p ⊗ k ⊗ q ⊗ l) ⊕ (p ⊗ q ⊗ k ⊗ l)
k

2

p

2

k

2

(34)

= (k ⊗ k ⊗ p ⊗ p) ⊕ (k ⊗ p ⊗ k ⊗ p) ⊕ (k ⊗ p ⊗ p ⊗ k) ⊕
(p ⊗ k ⊗ k ⊗ p) ⊕ (p ⊗ k ⊗ p ⊗ k) ⊕ (p ⊗ p ⊗ k ⊗ k)

k

2

(35)

4

(36)

= 6 (k ⊗ k ⊗ k ⊗ k) = 6 ( k )

In general, the weighted relation R in our example is non-rational. However, it is rational if the semiring
i
i
is both commutative and idempotent. In that case, w0 w1 = ji (w0 ⊗ w1 )i = (w0 ⊗ w1 )i , where ji ∈ N
is the number of summands in the shufﬂe sum and is irrelevant thanks to idempotency.

4.3

Presentation Problems

Our next example illustrates how a partial auto-intersection algorithm might be affected by the presentation of its input.

a:ε:x /w0

ε:a:x /w2

ε:a:x /w2
0

(a)

0

a:a:x /w1

1

(b)

a:a:x /w1
a:ε:x /w0

a:a:x /w0w2
1

(c)

0

a:a:x /w1

1

Figure 5: (a), (b) Different presentations of the same relation R(3) ; (c) the auto-intersection
σ{1,2} (R(3) )

Provided that the weight semiring is commutative, the WFSMs in Figures 4.3a and 4.3b describe
i
i
the same relation, which for each i ∈ N maps ai+1 , ai+1 , x2i+1 to w0 ⊗ w1 ⊗ w2 . A naive algorithm
modeled on WFST determinization would fail to terminate on either machine, constructing a successful
path of length 2i + 1 for each i ∈ N. For example, on Figure 4.3a, it would allow unrolling the ﬁrst cycle
i times and then transitioning to the second cycle to allow the second tape to “catch up” with the ﬁrst.
A partial algorithm for auto-intersection might attempt to detect and handle some such cases, allowing it to compute the correct auto-intersection (Figure 4.3c). It seems potentially easier to detect the
Figure 4.3b case than the Figure 4.3a case.
5

Again, this example can be derived by transducing the original shufﬂe example of Figure 4a. If all transitions in that
example are given weight ¯ in the semiring of interest, then its generalized composition {3=1} with a simple weighted
1
machine will produce Figure 4c by replacing all instances of x with w0 , etc.

4.4

Post’s Correspondence Problem

Post’s Correspondence Problem or PCP (Post, 1946) is a classical undecidable problem that is sometimes used to prove the undecidability of other problems. Mark-Jan Nederhof (personal communication)
pointed out its relevance to auto-intersection.
Deﬁnition: Given an alphabet Σ, an instance of PCP is a list of pairs of strings in Σ∗ : u1 , v1 , . . .
up , vp . A solution is a string s such that s = ui1 ui2 . . . uir = vi1 vi2 . . . vir for some non-empty index
sequence i1 , i2 , . . . ir ∈ [[1, p]]. This sequence may contain duplicates.
Taking an example from (Zhao, 2002), the instance abb, a , b, abb , a, bb has among its solutions the string abbaabbabbabb = u1 u3 u1 u1 u3 u2 u2 = v1 v3 v1 v1 v3 v2 v2 , obtained from the index sequence 1311322. For the sake of clarity, we show here both the instance and the solution in tabular form:
i
ui
vi

1
abb
a

2
b
abb

i
ui
vi

3
a
bb

1
abb
a

3
a
bb

1
abb
a

1
abb
a

3
a
bb

2
b
abb

2
b
abb

The language of solutions to a given instance is context-sensitive. That is, it is possible for a linear
bounded automaton to determine whether a given string s is a solution, simply by considering all index
sequences of length ≤ 2|s|.6
What is not decidable, in general, is whether this context-sensitive language of solutions is nonempty. To put this another way, the set of PCP instances with at least one solution is not recursive
(although it is recursively enumerable).
An instance of PCP can be represented as a 2-tape automaton, A(2) , with a unique state, that is both
initial and ﬁnal, and p transitions labeled with pairs of strings ui : vi , as illustrated in Figure 6a. The set of
all solutions to this instance equals π 1 (σ{1=2} (R(A(2) ))). If one wishes instead to obtain the language
of index sequences of each solution, one can represent the instance as a 3-tape automaton A(3) with an
additional tape of indices i ∈ [[1, p]], as illustrated in Figure 6b, and construct π 1 (σ{2=3} (R(A(3) ))).

abb:a
0

(a)

a:bb

1:abb:a

b:abb

0

(b)

2:b:abb

3:a:bb

Figure 6: An instance of a PCP (a) without and (b) with an additional tape of indices
This reduction from PCP to auto-intersection demonstrates that it is undecidable whether the result
of an unweighted 2-tape auto-intersection is empty.
Furthermore, this implies that there can be no partial auto-intersection algorithm that is “complete”
in that it always returns a correct FSM if the auto-intersection is rational, and always terminates with
an error code otherwise. If such an algorithm did exist, one could use it as follows to determine the
emptiness of an unweighted auto-intersection (and hence to determine the existence of a solution to a
PCP instance, which is impossible in general). If the algorithm returned an FSM, we would test it for
emptiness by determining whether there was at least one path from an initial to a ﬁnal state. If the
algorithm returned an error code, we would know that the result was non-rational and hence could not
be empty.
Despite this gloomy result, some recent work (Zhao, 2002) has explored heuristic tests that can
identify some PCP instances as empty, as well as heuristic search methods that try to ﬁnd a single solution
6

We may assume without loss of generality that ε, ε is not among the strings in the instance. Then if s = ui1 ui2 . . . uir =
vi1 vi2 . . . vir is a solution, we have r ≤ |ui1 ui2 . . . uir vi1 vi2 . . . vir | = |ss| = 2|s|.

to a PCP quickly (although not the full language of solutions). These methods might provide a starting
point for constructing a useful partial algorithm for auto-intersection.

5

Conclusion

We have provided deﬁnitions and notation for the central operations on weighted n-ary relations and the
ﬁnite-state machines that describe the rational cases. Our notation is informed by regarding these objects
as weighted databases. This perspective is pedagogically useful and motivates potential applications.
We focused primarily on the important join operation 1, and the related operations of generalized
composition
and auto-intersection σ{1=2} . In some cases, these operators preserve rationality. In
general, they do not, and we showed that the resulting relations, while individually decidable (at the level
of individual tuples), can have undecidable emptiness as a class.
Our question for future research is whether there exists a partial or approximate algorithm for autointersection that can handle some practical cases of inﬁnite relations. This would imply the existence of
a similar algorithm for join.
There is some precedent for such investigations. Regarding partial algorithms, we already noted the
work of (Zhao, 2002) on partial solutions to the generally undecidable Post’s Correspondence Problem,
which reduces to our problem. In the speech and language processing community, researchers manage
to make practical use of a WFSM determinization algorithm that is not guaranteed to terminate when
no answer exists (Mohri, 1997).7 As for approximations, context-free languages are not in general
rational, but they can be usefully approximated by FSMs that accept a close superset or subset (Nederhof,
2000). Approximation by pruning is an option for FSMs weighted by probabilities. Where a naive autointersection algorithm would run forever, in an attempt to generate an inﬁnite-state machine, it might be
possible to obtain a reasonable ﬁnite-state machine by pruning away work on low-probability paths.

Acknowledgments
We wish to thank Mark-Jan Nederhof for discussion of our work at an earlier stage. It was he who saw
the relationship between auto-intersection and Post’s correspondence problem.

References
Bangalore, Srinivas and Michael Johnston. 2000. Finite-state multimodal parsing and understanding. In
Proc. of the 17th COLING, pages 369–375, Saarbr¨ cken, Germany, August.
u
Eilenberg, Samuel. 1974. Automata, Languages, and Machines, volume A. Academic Press, San Diego.
Eisner, Jason. 2002. Parameter estimation for probabilistic ﬁnite-state transducers. In Proceedings of
the 40th Annual Meeting of the Association for Computational Linguistics, Philadelphia, July.
Elgot, Calvin C. and Jorge E. Mezei. 1965. On relations deﬁned by generalized ﬁnite automata. IBM
Journal of Research and Development, 9(1):47–68.
Kaplan, Ronald M. and Martin Kay. 1994. Regular models of phonological rule systems. Computational
Linguistics, 20(3):331–378.
7

Even though Mohri also exhibits a terminating algorithm for that problem.

Kay, Martin. 1987. Nonconcatenative ﬁnite-state morphology. In Proc. 3rd Int. Conf. EACL, pages
2–10, Copenhagen, Denmark.
Kempe, Andr´ . 2004. NLP applications based on weighted multi-tape automata. In Proc. 11th Conf.
e
TALN, pages 253–258, Fes, Morocco, April.
Kempe, Andr´ , Franck Guingne, and Florent Nicart. 2004. Algorithms for weighted multi-tape aue
tomata. Research report 2004/031, Xerox Research Centre Europe, Meylan, France. (available from
www.xrce.xerox.com and www.arXiv.org/abs/cs.CL/0406003).
Kiraz, George Anton. 2000. Multitiered nonlinear morphology using multitape ﬁnite automata: a case
study on Syriac and Arabic. Computational Lingistics, 26(1):77–105, March.
Knight, Kevin and Jonathan Graehl. 1998. Machine transliteration. Computational Linguistics, 24(4).
Kuich, Werner and Arto Salomaa. 1986. Semirings, Automata, Languages. Number 5 in EATCS
Monographs on Theoretical Computer Science. Springer Verlag, Berlin, Germany.
Lehmann, Daniel J. 1977. Algebraic structures for transitive closure. Theoretical Computer Science,
4(1):59–76.
Livescu, Karen, James Glass, and Jeff Bilmes. 2003. Hidden feature models for speech recognition
using dynamic Bayesian networks. In 8th European Conference on Speech Communication and
Technology (Eurospeech).
Mohri, Mehryar. 1997. Finite-state transducers in language and speech processing. Computational
Linguistics, 23(2):269–312.
Mohri, Mehryar, Fernando C. N. Pereira, and Michael Riley. 1998. A rational design for a weighted
ﬁnite-state transducer library. Lecture Notes in Computer Science, 1436:144–158.
Nederhof, Mark-Jan. 2000. Practical experiments with regular approximation of context-free languages.
Computational Linguistics, 26(1).
Post, Emil. 1946. A variant of a recursively unsolvable problem. Bulletin of the American Mathematical
Society, 52:264–268.
Rabin, Michael O. and Dana Scott. 1959. Finite automata and their decision problems. IBM Journal of
Research and Development, 3(2):114–125.
Rosenberg, Arnold L. 1964. On n-tape ﬁnite state acceptors. In IEEE Symposium on Foundations of
Computer Science (FOCS), pages 76–81.
´
´e
Sakarovitch, Jacques. 2003. El´ ments de theorie des automates. Editions Vuibert, Paris, France.
Zhao, Ling. 2002. Tackling Post’s Correspondence Problem. In Jonathan Schaeffer, Martin M¨ ller,
u
and Yngvi Bj¨ rnsson, editors, Proceedings of the Third International Conference on Computers and
o
Games, CG 2002, volume 2883 of Lecture Notes in Computer Science, pages 326–344, Edmonton,
Canada, July 25-27. Springer-Verlag. Revised edition (January 1, 2004).

