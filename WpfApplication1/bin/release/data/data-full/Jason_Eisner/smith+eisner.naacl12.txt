Unsupervised Learning on an Approximate Corpus∗
Jason Smith and Jason Eisner
Center for Language and Speech Processing
Johns Hopkins University
3400 N. Charles St., Baltimore, MD 21218, USA
{jsmith,jason}@cs.jhu.edu
Unsupervised learning techniques can take advantage of large amounts of unannotated text, but the
largest text corpus (the Web) is not easy to use in
its full form. Instead, we have statistics about this
corpus in the form of n-gram counts (Brants and
Franz, 2006). While n-gram counts do not directly
provide sentences, a distribution over sentences can
be estimated from them in the same way that ngram language models are estimated. We treat this
distribution over sentences as an approximate corpus and show how unsupervised learning can be
performed on such a corpus using variational inference. We compare hidden Markov model (HMM)
training on exact and approximate corpora of various sizes, measuring speed and accuracy on unsupervised part-of-speech tagging.

1

Introduction

We consider the problem of training generative models on very large datasets in sublinear time. It is well
known how to train an HMM to maximize the likelihood of a corpus of sentences. Here we show how
to train faster on a distribution over sentences that
compactly approximates the corpus. The distribution is given by an 5-gram backoff language model
that has been estimated from statistics of the corpus.
In this paper, we demonstrate our approach on
a traditional testbed for new structured-prediction
learning algorithms, namely HMMs. We focus on
unsupervised learning. This serves to elucidate the
structure of our variational training approach, which
stitches overlapping n-grams together rather than
treating them in isolation. It also conﬁrms that at
least in this case, accuracy is not harmed by the
key approximations made by our method. In future,
we hope to scale up to the Google n-gram corpus
(Brants and Franz, 2006) and learn a more detailed,
explanatory joint model of tags, syntactic dependencies, and topics. Our intuition here is that web-scale
data may be needed to learn the large number of lexically and contextually speciﬁc parameters.
∗

Work was supported in part by NSF grant No. 0347822.

1.1

Formulation

Let w (“words”) denote an observation sequence,
and let t (“tags”) denote a hidden HMM state sequence that may explain w. This terminology is
taken from the literature on inducing part-of-speech
(POS) taggers using a ﬁrst-order HMM (Merialdo,
1994), which we use as our experimental setting.
Maximum a posteriori (MAP) training of an
HMM pθ seeks parameters θ to maximize
N·

c(w) log
w

pθ (w, t) + log Pr prior (θ) (1)
t

where c is an empirical distribution that assigns
probability 1/N to each of the N sentences in a
training corpus. Our technical challenge is to generalize this MAP criterion to other, structured distributions c that compactly approximate the corpus.
Speciﬁcally, we address the case where c is given
by any probabilistic FSA, such as a backoff language model—that is, a variable-order Markov
model estimated from corpus statistics. Similar sentences w share subpaths in the FSA and cannot easily be disentangled. The support of c is typically inﬁnite (for a cyclic FSA) or at least exponential. Hence
it is no longer practical to compute the tagging distribution p(t | w) for each sentence w separately, as in
traditional MAP-EM or gradient ascent approaches.
We will maximize our exact objective, or a cheaper
variational approximation to it, in a way that crucially allows us to retain the structure-sharing.
1.2

Motivations

Why train from a distribution rather than a corpus?
First, the foundation of statistical NLP is distributions over strings that are speciﬁed by weighted automata and grammars. We regard parameter estimation from such a distribution c (rather than from a
sample) as a natural question. Previous work on
modeling c with a distribution from another family was motivated by approximating a grammar or

131
2012 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages 131–141,
Montr´ al, Canada, June 3-8, 2012. c 2012 Association for Computational Linguistics
e

model rather than generalizing from a dataset, and
hence removed latent variables while adding parameters (Nederhof, 2000; Mohri and Nederhof, 2001;
Liang et al., 2008), whereas we do the reverse.
Second, in practice, one may want to incorporate
massive amounts of (possibly out-of-domain) data
in order to get better coverage of phenomena. Massive datasets usually require a simple model (given a
time budget). We propose that it may be possible to
use a lot of data and a good model by reducing the
accuracy of the data representation instead. While
training will become more complicated, it can still
result in an overall speedup, because a frequent 5gram collapses into a single parameter of the estimated distribution that only needs to be processed
once per training iteration. By pruning low-count
n-grams or reducing the maximum n below 5, one
can further increase data volume for the ﬁxed time
budget at the expense of approximation quality.
Third, one may not have access to the original
corpus. If one lacks the resources to harvest the
web, the Google n-gram corpus was derived from
over a trillion words of English web text. Privacy
or copyright issues may prevent access, but one may
still be able to work with n-gram statistics: Michel
et al. (2010) used such statistics from 5 million
scanned books. Several systems use n-gram counts
(Bergsma et al., 2009; Lin et al., 2009) or other
web statistics (Lapata and Keller, 2005) as features
within a classiﬁer. A large language model from ngram counts yields an effective prior over hypotheses in tasks like machine translation (Brants et al.,
2007). We similarly construct an n-gram model, but
treat it as the primary training data whose structure
is to be explained by the generative HMM. Thus our
criterion does not explain the n-grams in isolation,
but rather tries to explain the likely full sentences
w that the model reconstructed from overlapping ngrams. This is something like shotgun sequencing,
in which likely DNA strings are reconstructed from
overlapping short reads (Staden, 1979); however, we
train an HMM on the resulting distribution rather
than merely trying to ﬁnd its mode.
Finally, unsupervised HMM training discovers latent structure by approximating an empirical distribution c (the corpus) with a latent-variable distribution p (the trained HMM) that has fewer parameters.
We show how to do the same where the distribution
132

c is not a corpus but a ﬁnite-state distribution. In
general, this ﬁnite-state c could represent some sophisticated estimate of the population distribution,
using shrinkage, word classes, neural-net predictors,
etc. to generalize in some way beyond the training
sample before ﬁtting p. For the sake of speed and
clear comparison, however, our present experiments
take c to be a compact approximation to the sample
distribution, requiring only n-grams.
Spectral learning of HMMs (Hsu et al., 2009)
also learns from a collection of n-grams. It has the
striking advantage of converging globally to the true
HMM parameters (under a certain reparameterization), with enough data and under certain assumptions. However, it does not exploit context beyond
a trigram (it will not maximize, even locally, the
likelihood of a ﬁnite sample of sentences), and cannot exploit priors or structure—e.g., that the emissions are consistent with a tag dictionary or that the
transitions encode a higher-order or factorial HMM.
Our more general technique extends to other latentvariable models, although it suffers from variational
EM’s usual local optima and approximation errors.

2

A variational lower bound

Our starting point is the variational EM algorithm
(Jordan et al., 1999). Recall that this maximizes a
lower bound on the MAP criterion of equation 1, by
bounding the log-likelihood subterm as follows:
log

t pθ (w, t)

= log
≥

(2)

t q(t)(pθ (w, t)/q(t))

t q(t) log(pθ (w, t)/q(t))

= Eq(t) [log pθ (w, t) − log q(t)]

(3)

This use of Jensen’s inequality is valid for any distribution q. As Neal and Hinton (1998) show, the EM
algorithm (Dempster et al., 1977) can be regarded
as locally maximizing the resulting lower bound by
alternating optimization, where q is a free parameter. The E-step optimizes q for ﬁxed θ, and the Mstep optimizes θ for ﬁxed q. These computations are
tractable for HMMs, since the distribution q(t) =
pθ (t | w) that is optimal at the E-step (which makes
the inequality tight) can be represented as a lattice
(a certain kind of weighted DFA), and this makes
the M-step tractable via the forward-backward algorithm. However, there are many extensions such as

factorial HMMs and Bayesian HMMs in which an
expectation under pθ (t | w) involves an intractable
sum. In this setting, one may use variational EM, in
which q is restricted to some parametric family qφ
that will permit a tractable M-step. In this case the
E-step chooses the optimal values of the variational
parameters φ; the inequality is no longer tight.
There are two equivalent views of how this procedure is applied to a training corpus. One view is
that the corpus log-likelihood is just as in (2), where
w is taken to be the concatenation of all training
sentences. The other view is that the corpus loglikelihood is a sum over many terms of the form (2),
one for each training sentence w, and we bound each
summand individually using a different qφ .
However, neither view leads to a practical implementation in our setting. We can neither concatenate
all the relevant w nor loop over them, since we want
the expectation of (2) under some distribution c(w)
such that {w : c(w) > 0} is very large or inﬁnite.
Our move is to make q be a conditional distribution
q(t | w) that applies to all w at once. The following holds by applying Jensen’s inequality separately
to each w in the expectation (this is valid since for
each w, q(t | w) is a distribution):
Ec(w) log

t pθ (w, t)

= Ec(w) log
≥ Ec(w)

t q(t

t q(t

(4)

| w)(pθ (w, t)/q(t | w))

| w) log(pθ (w, t)/q(t | w))

= Ecq(w,t) [log pθ (w, t) − log q(t | w)]

(5)

where we use cq(w, t) to denote the joint distribution c(w) · q(t | w). Thus, just as c is our approximate corpus, cq is our approximate tagged corpus.
Our variational parameters φ will be used to parameterize cq directly. To ensure that cqφ can indeed
be expressed as c(w) · q(t | w), making the above
bound valid, it sufﬁces to guarantee that our variational family preserves the marginals:
(∀w) t cqφ (w, t) = c(w)

3

Finite-state encodings and algorithms

In the following, we will show how to maximize
(5) for particular families of p, c, and cq that can
be expressed using ﬁnite-state machines (FSMs)—
that is, ﬁnite-state acceptors (FSAs) and transducers
(FSTs). This general presentation of our method enables variations using other FSMs.
133

A path in an FSA accepts a string. In an FST,
each arc is labeled with a “word : tag” pair, so that a
path accepts a string pair (w, t) obtained by respectively concatenating the words and the tags encountered along the path. Our FSMs are weighted in the
(+, ×) semiring: the weight of any path is the product (×) of its arc weights, while the weight assigned
to a string or string pair is the total weight (+) of all
its accepting paths. An FSM is unambiguous if each
string or string pair has at most one accepting path.
Figure 1 reviews how to represent an HMM POS
tagger as an FST (b), and how composing this with
an FSA that accepts a single sentence gives us the
familiar HMM tagging lattice as an FST (c). The
forward-backward algorithm sums over paths in the
lattice via dynamic programming (Rabiner, 1989).
In section 3.1, we replace the straight-line FSA
of Figure 1a with an FSA that deﬁnes a more general distribution c(w) over many sentences. Note
that we cannot simply use this as a drop-in replacement in the construction of Figure 1. That would
correspond to running EM on a single but uncertain sentence (distributed as c(w)) rather than a collection of observed sentences. For example, in the
case of an ordinary training corpus of N sentences,
the new FSA would be a parallel union (sum) of
N straight-line paths—rather than a serial concatenation (product) of those paths as in ordinary EM
(see above). Running the forward algorithm on the
resulting lattice would compute Ec(w) t p(w, t),
whose log is log Ec(w) t p(w, t) rather than our
desired Ec(w) log t p(w, t). Instead, we use c in
section 3.2 to construct a variational family cqφ . We
then show in sections 3.3–3.5 how to compute and
locally maximize the variational lower bound (5).
3.1

Modeling a corpus with n-gram counts

n-gram backoff language models have been used for
decades in automatic speech recognition and statistical machine translation. We follow the usual FSA
construction (Allauzen et al., 2003). The state of a 5gram FSA model c(w) must remember the previous
4-gram. For example, it would include an arc from
state defg (the previous 4-gram) to state efgh with
label h and weight c(h | defg). Then, with appropriate handling of boundary conditions, a sentence
w = . . . defghi . . . is accepted along a single path of
weight c(w) = · · · c(h | defg) · c(i | efgh) · · · . Arcs

(a) w

Time

flies

like

an

arrow
w:N

(b) p(w,t)

w:V

Start

V

Stop
N

w:V
w:DT

like : Prep

flies : V
Time : V

(c) w o p(w,t)

Start

Time : N

V
N

flies : N

V

flies : V
flies : N

like : V
like : Prep

N

w:V
Prep
V

an : DT
an : DT

DT

DT
arrow : N

N

like : V

Figure 1: Ordinary HMM tagging with ﬁnite-state machines. An arc’s label may have up to three components:
“word:tag / weight.” (Weights are suppressed for space. State labels are not part of the machine but suggest the history
recorded by each state.) (a) w is an FSA that generates the sentence “Time ﬂies like an arrow”; all arcs have probability
1. (b) p(w, t) is an FST representing an HMM (many arcs are not shown and words are abbreviated as “w”). Each arc
w : t is weighted by the product of transition and emission probabilities, p(t | previous t) · p(w | t). Composing (a)
with (b) yields (c), an FST that encodes the joint probabilities p(w, t) of all possible taggings of the sentence w.

of weight 0 can be omitted from the FSA.1
To estimate a conditional probability like c(h |
defg) above, we simply take an unsmoothed ratio of
two n-gram counts. This ML estimation means that
c will approximate as closely as possible the training sample from which the counts were drawn. That
gives a fair comparison with ordinary EM, which
trains directly on that sample. (See discussion at the
end of section 1.2 for alternatives.)
Yet we decline to construct a full 5-gram model,
which would not be as compact as desired. A collection of all web 5-grams would be nearly as large
as the web itself (by Zipf’s Law). We may not have
such a collection. For example, the Google n-gram
corpus version 2 contains counts only for 1-grams
that appear at least 40 times and 2-, 3-, 4-, and 5grams that appear at least 10 times (Lin et al., 2009).
1

The FSA’s initial state is the unigram history #, and its ﬁnal
states (which have no outgoing arcs) are the other states whose
n-gram labels end in #. Here # is a boundary symbol that falls
between sentences. To compute the weighted transitions, sentence boundaries must be manually or automatically annotated,
either on the training corpus as in our present experiments, or
directly on the training n-grams if we have only those.
To automatically ﬁnd boundaries in an n-gram collection,
one could apply a local classiﬁer to each n-gram. But in principle, one could exploit more context and get a globally consistent
annotation by stitching the n-grams together and applying the
methods of this paper—replacing pθ with an existing CRF sentence boundary detector, replacing c with a document-level (not
sentence-level) language model, and optimizing cqφ to be a version of c that is probabilistically annotated with sentence boundaries, which yields our desired distribution over sentences.

134

Instead, we construct a backoff language model.
This FSA has one arc for each n-gram in the collection. Our algorithm’s runtime (per iteration) will
be linear in the number of arcs. If the 5-gram defgh
is not in our collection, then there can be no h arc
leaving defg. When encountering h in state defg, the
automaton will instead take a failure arc (Allauzen
et al., 2003) to the “backoff state” efg. It may be
able to consume the h from that state, on an arc with
weight c(h | efg); or it may have to back off further
to fg. Each state’s failure arc is weighted such that
the state’s outgoing arcs sum to 1. It is labeled with
the special symbol Φ, which does not contribute to
the word string accepted along a path.
We take care never to allow backoff to the empty
state ,2 since we ﬁnd that c(w) is otherwise too
coarse an approximation to English: sampled sentences tend to be disjointed, with some words generated in complete ignorance of their left context.
3.2

The variational distribution cq(w, t)

The “variational gap” between (4) and (5) is
Ec(w) KL(q(t | w) || pθ (t | w)). That is, the bound
is good if q does a good job of approximating pθ ’s
tagging distribution on a randomly drawn sentence.
Note that n − 1 is the order of our n-gram Markov
2

To prevent such backoff, it sufﬁces to include all 2-grams
with count > 0. But where the full collection of 2-grams is
unavailable or too large, one can remove the empty state (and
recursively remove all states that transition only to removed
states), and then renormalize the model locally or globally.

model c(w) (i.e., each word is chosen given the previous n − 1 words). Let np − 1 be the order of the
HMM pθ (w, t) that we are training: i.e., each tag is
chosen given the previous np − 1 tags. Our experiments take np = 2 (a bigram HMM) as in Figure 1.
We will take qφ (t | w) to be a conditional Markov
model of order nq − 1.3 It will predict the tag at position i using a multinomial conditioned on the preceding nq −1 tags and on the word n-gram ending at
position i (where n is as large as possible such that
this n-gram is in our training collection). φ is the
collection of all multinomial parameters.
If nq = np , then our variational gap can be made 0
as in ordinary non-variational EM (see section 3.5).
In our experiments, however, we save memory by
choosing nq = 1. Thus, our variational gap is tight
to the extent that a word’s POS tag under the model
pθ is conditionally independent of previous tags and
the rest of the sentence, given an n-word window.4
This is the assumption made by local classiﬁcation
models (Punyakanok et al., 2005; Toutanova and
Johnson, 2007). Note that it is milder than the “one
tagging per n-gram” hypothesis (Dawborn and Curran, 2009; Lin et al., 2009), which claims that each
5-gram (and therefore each sentence!) is unambiguous as to its full tagging. In contrast, we allow that
a tag may be ambiguous even given an n-word window; we merely suppose that there is no further disambiguating information accessible to pθ .5
We can encode the resulting cq(w, t) as an FST.
With nq = 1, the states of cq are isomorphic to the
states of c. However, an arc in c from defg with
label h and weight 0.2 is replaced in cq by several
arcs—one per tag t—with label h : t and weight
0.2 · qφ (t | defgh).6 We remark that an encoding of
3

A conditional Markov model is a simple case of a
maximum-entropy Markov model (McCallum et al., 2000).
4
At present, the word being tagged is the last word in the
window. We do have an efﬁcient modiﬁcation in which the window is centered on the word, by using an FST cq that delays the
emission of a tag until up to 2 subsequent words have been seen.
5
With difﬁculty, one can construct English examples that
violate our assumption. (1) “Some monitor lizards from
Africa . . . ” versus “Some monitor lizards from a distance . . . ”:
there are words far away from “monitor” that help disambiguate
whether “monitor” is a noun or a verb. (“Monitor lizards” are
a species, but some people like to monitor lizards.) (2) “Time
ﬂies”: “ﬂies” is more likely to be a noun if “time” is a verb.
6
In the case nq > 1, the states of c would need to be split
in order to remember nq − 1 tags of history. For example, if

135

q(t | w) as an FST would be identical except for
dropping the c factor (e.g., 0.2) from each weight.
Composing c ◦ q would then recover cq.
This construction associates one variational parameter in φ with each arc in cq—that is, with each
pair (arc in c, tag t), if nq = 1. There would be little point in sharing these parameters across arcs of
cq, as that would reduce the expressiveness of the
variational distribution without reducing runtime.7
Notice that maximizing equation (5) jointly learns
not only a compact slow HMM tagger pθ , but also a
large fast tagger qφ that simply memorizes the likely
tags in each n-gram context. This is reminiscent of
structure compilation (Liang et al., 2008).
3.3

Computing the variational objective

The expectation in equation (5) can now be computed efﬁciently and elegantly by dynamic programming over the FSMs, for a given θ and φ.
We exploit our representation of cqφ as an FSM
over the (+, ×) semiring. The path weights represent a probability distribution over the paths. In general, it is efﬁcient to compute the expected value of
a random FSM path, for any deﬁnition of value that
decomposes additively over the path’s arcs. The approach is to apply the forward algorithm to a version
of cqφ where we now regard each arc as weighted
by an ordered pair of real numbers. The (+, ×) operations for combining weights (section 3) are replaced with the operations of an “expectation semiring” whose elements are such pairs (Eisner, 2002).
Suppose we want to ﬁnd Ecqφ (w,t) log qφ (t | w).
To reduce this to an expected value problem, we
must assign a value to each arc of cqφ such that the
c is Figure 1a, splitting its states with nq = 2 would yield a
cq with a topology like Figure 1c, but with each arc having an
independent variational parameter.
7
One could increase the number of arcs and hence variational parameters by splitting the states of cq to remember more
history. In particular, one could increase the width nq of the tag
window, or one could increase the width of the word window by
splitting states of c (without changing the distribution c(w)).
Conversely, one could reduce the number of variational parameters by further restricting the variational family. For example, requiring q(t | w) to have entropy 0 (analogous to “hard
EM” or “Viterbi EM”) would associate a single deterministic
tag with each arc of c. This is fast, makes cq as compact as c,
and is still milder than “one tagging per n-gram.” More generously, one could allow up to 2 tags per arc of c, or use a lowdimensional representation of the arc’s distribution over tags.

total value of a path accepting (w, t) is log qφ (t |
w). Thus, let the value of each arc in cqφ be the log
of its weight in the isomorphic FST qφ (t | w).8
We introduce some notation to make this precise.
A state of cqφ is a pair of the form [hc , hq ], where hc
is a state of c (e.g., an (n − 1)-word history) and hq
is an (nq − 1)-tag history. We saw in the previous
section that an arc a leaving this state, and labeled
with w : t where w is a word and t is a tag, will
def
have a weight of the form ka = c(w | hc )φa where
def
def
φa = qφ (t | hc w, hq ). We now let the value va =
log φa .9 Then, just as the weight of a path accepting
(w, t) is a ka = cqφ (w, t), the value of that path
is a va = log qφ (t | w), as desired.
To compute the expected value r over all paths,
¯
we follow a generalized forward-backward recipe
(Li and Eisner, 2009, section 4.2). First, run the forward and backward algorithms over cqφ .10 Now the
expected value is a sum over all arcs of cqφ , namely
r = a αa ka va βa , where αa denotes the forward
¯
probability of arc a’s source state and βa denotes
the backward probability of arc a’s target state.
Now, in fact, the expectation we need to compute
is not Ecqφ (w,t) log qφ (t | w) but rather equation (5).
So the value va of arc a should not actually be
def
log φa but rather log θa − log φa where θa = pθ (t |
8
The total value is then the sum of the logs, i.e., the log
of the product. This works because qφ is unambiguous, i.e., it
computes qφ (t | w) as a product along a single accepting path,
rather than summing over multiple paths.
9
The special case of a failure arc a goes from [hc , hq ] to
[hc , hq ], where hc is a backed-off version of hc . It is labeled
with Φ : , which does not contribute to the word string or
tag string accepted along a path. Its weight ka is the weight
c(Φ | hc ) of the corresponding failure arc in c from hc to hc .
def
We deﬁne va = 0, so it does not contribute to the total value.
10
Recall that the forward probability of each state is deﬁned
recursively from the forward probabilities of the states that have
arcs leading to it. As our FST is cyclic, it is not possible to visit
the states in topologically sorted order. We instead solve these
simultaneous equations by a relaxation algorithm (Eisner, 2002,
section 5): repeatedly sweep through all states, updating their
forward probability, until the total forward probability of all ﬁnal states is close to the correct total of 1 =
w,t cqφ (w, t)
(showing that we have covered all high-prob paths). A corresponding backward relaxation is actually not needed yet (we do
ˆ
need it for β in section 3.4): backward probabilities are just 1,
since cqφ is constructed with locally normalized probabilities.
When we rerun the forward-backward algorithm after a parameter update, we use the previous solution as a starting point
for the relaxation algorithm. This greatly speeds convergence.

136

hp ) · pθ (w | t). This is a minor change—except that
va now depends on hp , which is the history of np −1
previous tags. If np > nq , then a’s start state does
not store such a long history. Thus, the value of a
actually depends on how one reaches a! It is properly written as vza , where za is a path ending with
a and z is sufﬁciently long to determine hp .11
Formally, let Za be a “partitioning” set of paths to
a, such that any path in cqφ from an initial state to
the start state of a must have exactly one z ∈ Za as
a sufﬁx, and each z ∈ Za is sufﬁciently long so that
vza is well-deﬁned. We can now ﬁnd the expected
value as r = a z∈Za αz
¯
z∈z kz ka vza βa .
The above method permits pθ to score the tag sequences of length np that are hypothesized by cqφ .
One can regard it as implicitly running the generalized forward-backward algorithm over a larger FST
that marries the structure of cqφ with the np -gram
HMM structure,12 so that each value is again local to
a single arc za. However, it saves space by working
directly on cqφ (which has manageable size because
we deliberately kept nq small), rather than materializing the larger FST (as bad as increasing nq to np ).
The Za trick uses O(CT nq ) rather than O(CT np )
space to store the FST, where C is the number of
arcs in c (= number of training n-grams) and T is
the number of tag types. With or without the trick,
runtime is O(CT np +BCT nq ), where B is the num11

By concatenating z’s start state’s hq with the tags along z.
Typically z has length np − nq (and Za consists of the paths
of that length to a’s start state). However, z may be longer if it
contains Φ arcs, or shorter if it begins with an initial state.
12
Constructed by lazy ﬁnite-state intersection of cqφ and pθ
(Mohri et al., 2000). These do not have to be n-gram taggers,
but must be same-length FSTs (these are closed under intersection) and unambiguous. Deﬁne arc values in both FSTs such
that for any (w, t), cqφ and pθ accept (w, t) along unique paths
of total values v = − log qφ (t | w) and v = log pθ (w, t), respectively. We now lift the weights into the expectation semiring (Eisner, 2002) as follows. In cqφ , replace arc a’s weight
ka with the semiring weight ka , ka va . In pθ , replace arc a ’s
weight with 1, va . Then if k = cqφ (w, t), the intersected
FST accepts (w, t) with weight k, k(v + v ) . The expectation of v + v over all paths is then a sum za αza rza βza over
arcs za of the intersected FST—we are using za to denote the
arc in the intersected FST that corresponds to “a in cqφ when
reached via path z,” and rza to denote the second component
of its semiring weight. Here αza and βza denote the forward
and backward probabilities in the intersected FST, deﬁned from
the ﬁrst components of the semiring weights. We can get them
more efﬁciently from the results of running forward-backward
on the smaller cqφ : αza = αz z∈z kz and βza = βa = 1.

ber of forward-backward sweeps (footnote 10). The
ordinary forward algorithm requires nq = np and
takes O(CT np ) time and space on a length-C string.
3.4

Computing the gradient as well

To maximize our objective (5), we compute its gradient with respect to θ and φ. We follow an efﬁcient
recipe from Li and Eisner (2009, section 5, case 3).
The runtime and space match those of section 3.3,
except that the runtime rises to O(BCT np ).13
First suppose that each va is local to a single arc.
ˆ
We replace each weight ka with ka = ka , ka va
in the so-called expectation semiring, whose sum
and product operations can be found in Li and Eisner (2009, Table 1). Using these in the forwardˆ
backward algorithm yields quantities αa and βa
ˆ
14 (Their
that also fall in the expectation semiring.
ﬁrst components are the old αa and βa .) The
¯ ¯
ˆ ˆ 16
desired gradient15
k, r is
ˆ
a αa ( ka )βa ,
ˆ
where ka = ( ka , (ka va )) = ( ka , ( ka )va +
ka ( va )). Here gives the vector of partial derivatives with respect to all φ and θ parameters. Yet each
ˆ
ka is sparse, with only 3 nonzero components, beˆ
cause ka depends on only one φ parameter (φa ) and
two θ parameters (via θa as deﬁned in section 3.3).
When np > nq , we sum not over arcs a of cqφ but
over arcs za of the larger FST (footnote 12). Again
we can do this implicitly, by using the short path za
in cqφ in place of the arc za. Each state of cqφ must
ˆ
then store α and β values for each of the T np −nq
ˆ
states of the larger FST that it corresponds to. (In the
case np − nq = 1, as in our experiments, this fortunately does not increase the total asymptotic space,
13
An alternative would be to apply back-propagation
(reverse-mode automatic differentiation) to section 3.3’s computation of the objective. This would achieve the same runtime
as in section 3.3, but would need as much space as time.
14
This also computes our objective r: summing the α’s of the
¯
ˆ
¯ ¯
¯
ﬁnal states of cqφ gives k, r where k = 1 is the total probability of all paths. This alternative computation of the expectation
r, using the forward algorithm (instead of forward-backward)
¯
but over the expectation semiring, was given by Eisner (2002).
15
¯
We are interested in r. k is just a byproduct. We re¯
¯
¯
mark that k = 0, even though k = 1 for any valid parameter
¯
vector φ (footnote 14), as increasing φ invalidly can increase k.
16

def

By a product of pairs we always mean k, r s, t =
ks, kt + rs , just as in the expectation semiring, even though
ˆ
the pair ka is not in that semiring (its components are vectors
rather than scalars). See (Li and Eisner, 2009, section 4.3). We
def
also deﬁne scalar-by-pair products as k s, t = ks, kt .

137

since each state of cqφ already has to store T arcs.)
With more cleverness, one can eliminate this
extra storage while preserving asymptotic runtime
¯
(still using sparse vectors). Find
k, ( r)(1) =
¯
ˆ
αa k a , 0 β a .
ˆ
Also ﬁnd r, ( r)(2)
¯
¯
=
a
ka vza , (ka vza )
a
z∈Za αz
z∈z kz , kz
βa . Now our desired gradient r emerges as
¯
( r)(1) + ( r)(2) . The computation of ( r)(1)
¯
¯
¯
ˆa that depend
uses modiﬁed deﬁnitions of αa and β
ˆ
only on (respectively) the source and target states of
ˆ
a—not za.17 To compute them, initialize α (respecˆ
tively β) at each state to 1, 0 or 0, 0 according to
whether the state is initial (respectively ﬁnal). Now
iterate repeatedly (footnote 10) over all arcs a: Add
αa ka , 0 + z∈Za αz
ˆ
0, ka vza to the
z∈z kz
ˆ
α at a’s target state. Conversely, add ka , 0 βa to
ˆ
ˆ
the β at a’s source state, and for each z ∈ Za , add
ˆ
0, ka vza βa to the β at z’s source state.
z∈z kz
3.5

Locally optimizing the objective

Recall that cqφ associates with each [hc , hq , w] a
block of φ parameters that must be ≥ 0 and sum to
1. Our optimization method must enforce these constraints. A standard approach is to use a projected
gradient method, where after each gradient step on
φ, the parameters are projected back onto the probability simplex. We implemented another standard
approach: reexpress each block of parameters {φa :
def
a ∈ A} as φa = exp ηa / b∈A exp ηb , as is possible iff the φa parameters satisfy the constraints. We
then follow the gradient of r with respect to the new
¯
η parameters, given by ∂ r/∂ηa = φa (∂ r/∂φa −EA )
¯
¯
where EA = b φb (∂ r/∂φb ).
¯
Another common approach is block coordinate
ascent on θ and φ—this is “variational EM.” Mstep: Given φ, we can easily ﬁnd optimal estimates of the emission and transition probabilities θ.
They are respectively proportional to the posterior
expected counts of arcs a and paths za under cqφ ,
namely N · αa ka βa and N · αz
z∈z kz ka βa .
E-step: Given θ, we cannot easily ﬁnd the optimal φ (even if nq = np ).18 This was the rea17

First components αa and βa remain as in cqφ . αa sums
ˆ
ˆ
paths to a.
ka , 0 βa can’t quite sum over paths starting with
a (their early weights depend on z), but ( r)(2) corrects this.
¯
18
Recall that cqφ must have locally normalized probabilities
(to ensure that its marginal is c). If nq = np , the optimal φ
is as follows: we can reduce the variational gap to 0 by setting

son for gradient ascent. However, for any single
sum-to-1 block of parameters {φa : a ∈ A}, it
is easy to ﬁnd the optimal values if the others are
def
¯
held ﬁxed. We maximize LA = r + λA a∈A φa ,
where λA is a Lagrange multiplier chosen so that
the sum is 1. The partial derivative ∂ r/∂φa can be
¯
found using methods of section 3.4, restricting the
sums to za for the given a. For example, followdef
ing paragraphs 2–3 of section 3.4, let αa , ra =
def
ˆ ˆ 19
z∈Za αza , rza where αza , rza = αza βza .
Setting ∂LA /∂φa = 0 implies that φa is proportional to exp((ra + z∈Za αza log θza )/αa ).20
Rather than doing block coordinate ascent by updating one φ block at a time (and then recomputing
ra values for all blocks, which is slow), one can take
an approximate step by updating all blocks in parallel. We ﬁnd that replacing the E-step with a single
parallel step still tends to improve the objective, and
that this approximate variational EM is faster than
gradient ascent with comparable results.21

4
4.1

Experiments
Constrained unsupervised HMM learning

We follow the unsupervised POS tagging setup of
Merialdo (1994) and many others (Smith and Eisner, 2005; Haghighi and Klein, 2006; Toutanova and
Johnson, 2007; Goldwater and Grifﬁths, 2007; Johnson, 2007). Given a corpus of sentences, one seeks
the maximum-likelihood or MAP parameters of a bigram HMM (np = 2). The observed sentences, for
qφ (t | hc w, hq ) to the probability that t begins with t if we
randomly draw a sufﬁx w ∼ c(· | hc w) and randomly tag ww
with t ∼ pθ (· | ww, hq ). This is equivalent to using pθ with the
backward algorithm to conditionally tag each possible sufﬁx.
19
The ﬁrst component of αza βza is αza βza = αza · 1.
ˆ ˆ
20
If a is an arc of cqφ then ∂ r/∂φa is the second component
¯
ˆ
ˆ
of z∈Za αza (∂ kza /∂φa )βza . Then ∂LA /∂φa works out to
ˆ
z∈Za ca (rza +αza (log θza −log φa −1))+λA . Set to 0 and
solve for φa , noting that ca , αa , λA are constant over a ∈ A.
21
In retrospect, an even faster strategy might be to do a series
ˆ
ˆ
of block φ and β updates, updating β at a state (footnote 10) immediately after updating φ on the arcs leading from that state,
which allows a better block update at predecessor states. On an
acyclic machine, a single backward pass of this sort will reduce
the variational gap to 0 if nq = np (footnote 18). This is beˆ
cause, thanks to the up-to-date β, each block of arcs gets new φ
weights in proportion to relative sufﬁx path probabilities under
the new θ. After this backward pass, a single forward pass can
update the α values and collect expected counts for the M-step
that will update θ. Standard EM is a special case of this strategy.

138

us, are replaced by the faux sentences extrapolated
from observed n-grams via the language model c.
The states of the HMM correspond to POS tags as
in Figure 1. All transitions are allowed, but not all
emissions. If a word is listed in a provided “dictionary” with its possible tags, then other tags are given
0 probability of emitting that word. The EM algorithm uses the corpus to learn transition and emission probabilities that explain the data under this
constraint. The constraint ensures that the learned
states have something to do with true POS tags.
Merialdo (1994) spawned a long line of work
on this task. Ideas have included Bayesian learning methods (MacKay, 1997; Goldwater and Grifﬁths, 2007; Johnson, 2007), better initial parameters (Goldberg et al., 2008), and learning how to
constrain the possible parts of speech for a word
(Ravi and Knight, 2008), as well as non-HMM sequence models (Smith and Eisner, 2005; Haghighi
and Klein, 2006; Toutanova and Johnson, 2007).
Most of this work has used the Penn Treebank
(Marcus et al., 1993) as a dataset. While this
million-word Wall Street Journal (WSJ) corpus is
one of the largest that is manually annotated with
parts of speech, unsupervised learning methods
could take advantage of vast amounts of unannotated
text. In practice, runtime concerns have sometimes
led researchers to use small subsets of the Penn Treebank (Goldwater and Grifﬁths, 2007; Smith and Eisner, 2005; Haghighi and Klein, 2006). Our goal is
to point the way to using even larger datasets.
The reason for all this past research is that (Merialdo, 1994) was a negative result: while EM is
guaranteed to improve the model’s likelihood, it degrades the match between the latent states and true
parts of speech (if the starting point is a good one
obtained with some supervision). Thus, for the task
of POS induction, there must be something wrong
with the HMM model, the likelihood objective, or
the search procedure. It is clear that the model is far
too weak: there are many latent variables in natural
language, so the HMM may be picking up on something other than POS tags. Ultimately, ﬁxing this
will require richer models with many more parameters. But learning these (lexically speciﬁc) parameters will require large training datasets—hence our
present methodological exploration on whether it is
possible to scale up the original setting.

Setup

86

4.3

Results

In all experiments, our method achieves similar accuracy though slightly worse likelihood. Although
this method is meant to be a fast approximation of
EM, standard EM is faster on the smallest dataset
(WSJ-big). This is because this corpus is not much
bigger than the 5-gram language model built from it
(at our current pruning level), and so the overhead
of the more complex n-gram EM method is a net
disadvantage. However, when moving to larger corpora, the iterations of n-gram EM become as fast as
standard EM and then faster. We expect this trend
to continue as one moves to much larger datasets, as
the compression ratio of the pruned language model
relative to the original corpus will only improve.
The Google n-gram corpus is based on 50× more
data than our largest but could be handled in RAM.
22

Entropy-based pruning (Stolcke, 2000) may be a better selection method when one is in a position to choose. However,
count cutoffs were already used in the creation of the Google
n-gram corpus, and more complex methods of pruning may not
be practical for very large datasets.

139

84
82
Accuracy

We investigate how much performance degrades
when we approximate the corpus and train approximately with nq = 1. We examine two measures:
likelihood on a held-out corpus and accuracy in POS
tagging. We train on corpora of three different sizes:
• WSJ-big (910k words → 441k n-grams @ cutoff 3),
• Giga-20 (20M words → 2.9M n-grams @ cutoff 10),
• Giga-200 (200M wds → 14.4M n-grams @ cutoff 20).
These were drawn from the Penn Treebank (sections
2–23) and the English Gigaword corpus (Parker et
al., 2009). For held-out evaluation, we use WSJsmall (Penn Treebank section 0) or WSJ-big.
We estimate backoff language models for these
corpora based on collections of n-grams with n ≤ 5.
In this work, we select the n-grams by simple count
cutoffs as shown above,22 taking care to keep all 2grams as mentioned in footnote 2.
Similar to Merialdo (1994), we use a tag dictionary which limits the possible tags of a word to those
it was observed with in the WSJ, provided that the
word was observed at least 5 times in the WSJ. We
used the reduced tagset of Smith and Eisner (2005),
which collapses the original 45 ﬁne-grained part-ofspeech tags into just 17 coarser tags.

80
78
76
74
72

EM (WSJ-big)
N-gram EM (WSJ-big)
EM (Giga-20)
N-gram EM (Giga-20)
EM (Giga-200)
N-gram EM (Giga-200)
Time
EM (WSJ-big)
N-gram EM (WSJ-big)
EM (Giga-20)
N-gram EM (Giga-20)
EM (Giga-200)
N-gram EM (Giga-200)

Likelihood

4.2

Time

Figure 2: POS-tagging accuracy and log-likelihood after each iteration, measured on WSJ-big when training
on the Gigaword datasets, else on WSJ-small. Runtime
and log-likelihood are scaled differently for each dataset.
Replacing EM with our method changes runtime per iteration from 1.4s → 3.5s, 48s → 47s, and 506s → 321s.

5

Conclusions

We presented a general approach to training generative models on a distribution rather than on a training
sample. We gave several motivations for this novel
problem. We formulated an objective function similar to MAP, and presented a variational lower bound.
Algorithmically, we gave nontrivial general methods for computing and optimizing our variational
lower bound for arbitrary ﬁnite-state data distributions c, generative models p, and variational families q, provided that p and q are unambiguous samelength FSTs. We also gave details for speciﬁc useful
families for c, p, and q.
As proof of principle, we used a traditional HMM
POS tagging task to demonstrate that we can train
a model from n-grams almost as accurately as from
full sentences, and do so faster to the extent that the
n-gram dataset is smaller. More generally, we offer
our approach as an intriguing new tool to help semisupervised learning beneﬁt from very large datasets.

References
Cyril Allauzen, Mehryar Mohri, and Brian Roark. 2003.
Generalized algorithms for constructing statistical language models. In Proc. of ACL, pages 40–47.
Shane Bergsma, Dekang Lin, and Randy Goebel. 2009.
Web-scale n-gram models for lexical disambiguation.
In Proc. of IJCAI.
Thorsten Brants and Alex Franz. 2006. Web 1T 5-gram
version 1. Linguistic Data Consortium, Philadelphia.
LDC2006T13.
Thorsten Brants, Ashok C. Popat, Peng Xu, Franz J. Och,
and Jeffrey Dean. 2007. Large language models in
machine translation. In Proc. of EMNLP.
Tim Dawborn and James R. Curran. 2009. CCG
parsing with one syntactic structure per n-gram. In
Australasian Language Technology Association Workshop, pages 71–79.
Arthur P. Dempster, Nan M. Laird, and Donald B. Rubin. 1977. Maximum likelihood from incomplete data
via the EM algorithm. Journal of the Royal Statistical
Society. Series B (Methodological), 39(1):1–38.
Jason Eisner. 2002. Parameter estimation for probabilistic ﬁnite-state transducers. In Proc. of ACL, pages 1–8.
Yoav Goldberg, Meni Adler, and Michael Elhadad. 2008.
EM can ﬁnd pretty good HMM POS-taggers (when
given a good start). In Proc. of ACL, pages 746–754.
Sharon Goldwater and Thomas Grifﬁths. 2007. A fully
Bayesian approach to unsupervised part-of-speech tagging. In Proc. of ACL, pages 744–751.
Aria Haghighi and Dan Klein. 2006. Prototype-driven
learning for sequence models. In Proc. of NAACL,
pages 320–327.
Daniel Hsu, Sham M. Kakade, and Tong Zhang. 2009. A
spectral algorithm for learning hidden Markov models.
In Proc. of COLT.
Mark Johnson. 2007. Why doesn’t EM ﬁnd good HMM
POS-taggers? In Proc. of EMNLP-CoNLL, pages
296–305.
M. I. Jordan, Z. Ghahramani, T. S. Jaakkola, and L. K.
Saul. 1999. An introduction to variational methods
for graphical models. In M. I. Jordan, editor, Learning
in Graphical Models. Kluwer.
Mirella Lapata and Frank Keller. 2005. Web-based models for natural language processing. ACM Transactions on Speech and Language Processing.
Zhifei Li and Jason Eisner. 2009. First- and second-order
expectation semirings with applications to minimumrisk training on translation forests.
In Proc. of
EMNLP, pages 40–51.
Percy Liang, Hal Daum´ III, and Dan Klein. 2008.
e
Structure compilation: Trading structure for features.
In International Conference on Machine Learning
(ICML), Helsinki, Finland.

140

D. Lin, K. Church, H. Ji, S. Sekine, D. Yarowsky,
S. Bergsma, K. Patil, E. Pitler, R. Lathbury, V. Rao,
K. Dalwani, and S. Narsale. 2009. Unsupervised acquisition of lexical knowledge from n-grams. Summer workshop technical report, Center for Language
and Speech Processing, Johns Hopkins University.
David J. C. MacKay. 1997. Ensemble learning for hidden Markov models. http://www.inference.
phy.cam.ac.uk/mackay/abstracts/
ensemblePaper.html.
Mitchell P. Marcus, Mary Ann Marcinkiewicz, and Beatrice Santorini. 1993. Building a large annotated corpus of English: The Penn Treebank. Computational
Linguistics.
Andrew McCallum, Dayne Freitag, and Fernando
Pereira. 2000. Maximum entropy Markov models for
information extraction and segmentation. In Proc. of
ICML, pages 591–598.
B. Merialdo. 1994. Tagging English text with a probabilistic model. Computational Linguistics, 20(2):155–
171.
J.-B. Michel, Y. K. Shen, A. P. Aiden, A. Veres, M. K.
Gray, W. Brockman, The Google Books Team, J. P.
Pickett, D. Hoiberg, D. Clancy, P. Norvig, J. Orwant,
S. Pinker, M. A. Nowak, and E. L. Aiden. 2010.
Quantitative analysis of culture using millions of digitized books. Science, 331(6014):176–182.
Mehryar Mohri and Mark-Jan Nederhof. 2001. Regular approximation of context-free grammars through
transformation. In Jean-Claude Junqua and Gertjan van Noord, editors, Robustness in Language and
Speech Technology, chapter 9, pages 153–163. Kluwer
Academic Publishers, The Netherlands, February.
Mehryar Mohri, Fernando Pereira, and Michael Riley.
2000. The design principles of a weighted ﬁnitestate transducer library. Theoretical Computer Science, 231(1):17–32, January.
Radford M. Neal and Geoffrey E. Hinton. 1998. A view
of the EM algorithm that justiﬁes incremental, sparse,
and other variants. In M.I. Jordan, editor, Learning in
Graphical Models, pages 355–368. Kluwer.
Mark-Jan Nederhof.
2000.
Practical experiments
with regular approximation of context-free languages.
Computational Linguistics, 26(1).
Robert Parker, David Graff, Junbo Kong, Ke Chen, and
Kazuaki Maeda. 2009. English Gigaword fourth
edition. Linguistic Data Consortium, Philadelphia.
LDC2009T13.
V. Punyakanok, D. Roth, W. Yih, and D. Zimak. 2005.
Learning and inference over constrained output. In
Proc. of IJCAI, pages 1124–1129.
Lawrence R. Rabiner. 1989. A tutorial on hidden
Markov models and selected applications in speech

recognition. Proc. of the IEEE, 77(2):257–286, February.
Sujith Ravi and Kevin Knight. 2008. Minimized models
for unsupervised part-of-speech tagging. In Proc. of
ACL, pages 504–512.
Noah A. Smith and Jason Eisner. 2005. Contrastive estimation: Training log-linear models on unlabeled data.
In Proc. of ACL, pages 354–362.
R. Staden. 1979. A strategy of DNA sequencing employing computer programs. Nucleic Acids Research,
6(7):2601–2610, June.
Andreas Stolcke. 2000. Entropy-based pruning of backoff language models. In DARPA Broadcast News
Transcription and Understanding Workshop, pages
270–274.
Kristina Toutanova and Mark Johnson. 2007. A
Bayesian LDA-based model for semi-supervised partof-speech tagging. In Proc. of NIPS, volume 20.

141

