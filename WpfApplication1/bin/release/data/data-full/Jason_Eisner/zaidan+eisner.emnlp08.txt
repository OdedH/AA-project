Modeling Annotators:
A Generative Approach to Learning from Annotator Rationales∗
Omar F. Zaidan and Jason Eisner
Dept. of Computer Science, Johns Hopkins University
Baltimore, MD 21218, USA
{ozaidan,jason}@cs.jhu.edu
Abstract
A human annotator can provide hints to a machine learner
by highlighting contextual “rationales” for each of his
or her annotations (Zaidan et al., 2007). How can one
exploit this side information to better learn the desired
parameters θ? We present a generative model of how
a given annotator, knowing the true θ, stochastically
chooses rationales. Thus, observing the rationales helps
us infer the true θ. We collect substring rationales for
a sentiment classiﬁcation task (Pang and Lee, 2004) and
use them to obtain signiﬁcant accuracy improvements for
each annotator. Our new generative approach exploits the
rationales more effectively than our previous “masking
SVM” approach. It is also more principled, and could be
adapted to help learn other kinds of probabilistic classiﬁers for quite different tasks.

approach remains “data-driven” if the annotators repeatedly reﬁne their system against a corpus of labeled or unlabeled examples. This achieves high
performance in some domains, such as NP chunking (Brill and Ngai, 1999), but requires more analytical skill from the annotators. One empirical study
(Ngai and Yarowsky, 2000) found that it also required more annotation time than active learning.
1.2

Feature selection by humans

Many recent papers aim to reduce the amount of annotated data needed to train the parameters of a statistical model. Well-known paradigms include active learning, semi-supervised learning, and either
domain adaptation or cross-lingual transfer from existing annotated data.
A rather different paradigm is to change the actual task that is given to annotators, giving them a
greater hand in shaping the learned classiﬁer. After all, human annotators themselves are more than
just black-box classiﬁers to be run on training data.
They possess some introspective knowledge about
their own classiﬁcation procedure. The hope is to
mine this knowledge rapidly via appropriate questions and use it to help train a machine classiﬁer.
How to do this, however, is still being explored.

More recent work has focused on statistical classiﬁers. Training such classiﬁers faces the “credit assignment problem.” Given a training example x with
many features, which features are responsible for its
annotated class y? It may take many training examples to distinguish useful vs. irrelevant features.1
To reduce the number of training examples
needed, one can ask annotators to examine or propose some candidate features. This is possible even
for the very large feature sets that are typically used
in NLP. In document classiﬁcation, Raghavan et al.
(2006) show that feature selection by an oracle could
be helpful, and that humans are both rapid and reasonably good at distinguishing highly useful n-gram
features from randomly chosen ones, even when
viewing these n-grams out of context.
Druck et al. (2008) show annotators some features
f from a ﬁxed feature set, and ask them to choose a
class label y such that p(y | f ) is as high as possible.
Haghighi and Klein (2006) do the reverse: for each
class label y, they ask the annotators to propose a
few “prototypical” features f such that p(y | f ) is as
high as possible.

1.1

1.3

1

Background

Hand-crafted rules

An obvious option is to have the annotators directly
express their knowledge by hand-crafting rules. This
∗

This work was supported by National Science Foundation
grant No. 0347822 and the JHU WSE/APL Partnership Fund.
Special thanks to Christine Piatko for many useful discussions.

Feature selection in context

The above methods consider features out of context.
An annotator might have an easier time examining
1

Most NLP systems use thousands or millions of features,
because it is helpful to include lexical features over a large vocabulary, often conjoined with lexical or non-lexical context.

features in context to recognize whether they appear
relevant. This is particularly true for features that
are only modestly or only sometimes helpful, which
may be abundant in NLP tasks.
Thus, Raghavan et al. (2006) propose an active
learning method in which, while classifying a training document, the annotator also identiﬁes some features of that document as particularly relevant. E.g.,
the annotator might highlight particular unigrams as
he or she reads the document. In their proposal, a
feature that is highlighted in any document is assumed to be globally more relevant. Its dimension
in feature space is scaled by a factor of 10 so that
this feature has more inﬂuence on distances or inner
products, and hence on the learned classiﬁer.
1.4

Concerns about marking features

Despite the success of the above work, we have
several concerns about asking annotators to identify
globally relevant features.
First, a feature in isolation really does not have a
well-deﬁned worth. A feature may be useful only in
conjunction with other features,2 or be useful only
to the extent that other correlated features are not
selected to do the same work.
Second, it is not clear how an annotator would
easily view and highlight features in context, except for the simplest feature sets. In the phrase
Apple shares up 3%, there may be several features that ﬁre on the substring Apple—responding
to the string Apple, its case-invariant form apple,
its lemma apple- (which would also respond to apples), its context-dependent sense Apple2 , its part
of speech noun, etc. How does the annotator indicate which of these features are relevant?
Third, annotating features is only appropriate
when the feature set can be easily understood by a
human. This is not always the case. It would be hard
for annotators to read, write, or evaluate a description of a complex syntactic conﬁguration in NLP or
a convolution ﬁlter in machine vision.
Fourth, traditional annotation efforts usually try to
remain agnostic about the machine learning methods
2
For example, a linear classiﬁer can learn that most training
examples satisfy A → B by setting θA = −5 and θA∧B = +5,
but this solution requires selecting both A and A∧B as features.
More simply, a polynomial kernel can consider the conjunction
A ∧ B only if both A and B are selected as features.

and features to be used. The project’s cost is justiﬁed by saying that the annotations will be reused by
many researchers (perhaps in a “shared task”), who
are free to compete on how they tackle the learning
problem. Unfortunately, feature annotation commits
to a particular feature set at annotation time. Subsequent research cannot easily adjust the deﬁnition of
the features, or obtain annotation of new features.

2

Annotating Rationales

To solve these problems, we propose that annotators
should not select features but rather mark relevant
portions of the example. In earlier work (Zaidan et
al., 2007), we called these markings “rationales.”
For example, when classifying a movie review as
positive or negative, the annotator would also highlight phrases that supported that judgment. Figure 1
shows two such rationales.
A multi-annotator timing study (Zaidan et al.,
2007) found that highlighting rationale phrases
while reading movie reviews only doubled annotation time, although annotators marked 5–11 rationale substrings in addition to the simple binary class.
The beneﬁt justiﬁed the extra time. Furthermore,
much of the beneﬁt could have been obtained by giving rationales for only a fraction of the reviews.
In the visual domain, when classifying an image as containing a zoo, the annotator might circle
some animals or cages and the sign reading “Zoo.”
The Peekaboom game (von Ahn et al., 2006) was in
fact built to elicit such approximate yet relevant regions of images. Further scenarios were discussed in
(Zaidan et al., 2007): rationale annotation for named
entities, linguistic relations, or handwritten digits.
Annotating rationales does not require the annotator to think about the feature space, nor even to
know anything about it. Arguably this makes annotation easier and more ﬂexible. It also preserves
the reusability of the annotated data. Anyone is free
to reuse our collected rationales (section 4) to aid
in learning a classiﬁer with richer features, or a different kind of classiﬁer altogether, using either our
procedures or novel procedures.

3

Modeling Rationale Annotations

As rationales are more indirect than explicit features,
they present a trickier machine learning problem.

We wish to learn the parameters θ of some classiﬁer. How can the annotator’s rationales help us to
do this without many training examples? We will
have to exploit a presumed relationship between the
rationales and the optimal value of θ (i.e., the value
that we would learn on an inﬁnite training set).
This paper exploits an explicit, parametric model
of that relationship. The model’s parameters φ are
intended to capture what that annotator is doing
when he or she marks rationales. Most importantly,
they capture how he or she is inﬂuenced by the true
θ. Given this, our learning method will prefer values
of θ that would adequately explain the rationales (as
well as the training classiﬁcations).

After training, one should simply use the ﬁrst factor pθ (y | x) to classify test documents x. The second factor is irrelevant for test documents, since they
have not been annotated with rationales r.
The second factor may likewise be omitted for any
training documents i that have not been annotated
with rationales, as there is no ri to predict in those
cases. In the extreme case where no documents are
annotated with rationales, equation (1) reduces to
the standard training procedure.
3.2

Noisy channel design of rationale models

Here we are trying to model all the annotations, both
yi and ri . The ﬁrst factor predicts yi using an ordinary probabilistic classiﬁer pθ , while the novel second factor predicts ri using a model pφ of how annotators generate the rationale annotations.
The crucial point is that the second factor depends
on θ (since ri is supposed to reﬂect the relation between xi and yi that is modeled by θ). As a result,
the learner has an incentive to modify θ in a way
that increases the second factor, even if this somewhat decreases the ﬁrst factor on training data.4

Like ordinary class annotations, rationale annotations present us with a “credit assignment problem,”
albeit a smaller one that is limited to features that ﬁre
“in the vicinity” of the rationale r. Some of these
θ-features were likely responsible for the classiﬁcation y and hence triggered the rationale. Other such
θ-features were just innocent bystanders.
Thus, the interesting part of our model is pφ (r |
x, y, θ), which models the rationale annotation process. The rationales r reﬂect θ, but in noisy ways.
Taking this noisy channel idea seriously, pφ (r |
x, y, θ) should consider two questions when assessing whether r is a plausible set of rationales given
θ. First, it needs a “language model” of rationales:
does r consist of rationales that are well-formed a
priori, i.e., before θ is considered? Second, it needs
a “channel model”: does r faithfully signal the features of θ that strongly support classifying x as y?
If a feature contributes heavily to the classiﬁcation
of document x as class y, then the channel model
should tell us which parts of document x tend to be
highlighted as a result.
The channel model must know about the particular kinds of features that are extracted by f and
scored by θ. Suppose the feature not . . . gripping,5
with weight θh , is predictive of the annotated class y.
This raises the probabilities of the annotator’s highlighting each of various words, or combinations of
words, in a phrase like not the most gripping banquet on ﬁlm. The channel model parameters in φ

3
It would be preferable to integrate out φ (and even θ), but
more difﬁcult.
4
Interestingly, even examples where the annotation yi is
wrong or unhelpful can provide useful information about θ via
the pair (yi , ri ). Two annotators marking the same movie review might disagree on whether it is overall a positive or nega-

tive review—but the second factor still allows learning positive
features from the ﬁrst annotator’s positive rationales, and negative features from the second annotator’s negative rationales.
5
Our current experiments use only unigram features, to
match past work, but we use this example to outline how our
approach generalizes to complex linguistic (or visual) features.

3.1

A generative approach

For concreteness, we will assume that the task is
document classiﬁcation. Our training data consists
of n triples {(x1 , y1 , r1 ), ..., (xn , yn , rn )}), where xi
is a document, yi is its annotated class, and ri is its
rationale markup. At test time we will have to predict yn+1 from xn+1 , without any rn+1 .
We propose to jointly choose parameter vectors θ
and φ to maximize the following regularized conditional likelihood:3
n

p(yi , ri | xi , θ, φ) · pprior (θ, φ)

(1)

i=1
n
def

pθ (yi | xi ) · pφ (ri | xi , yi , θ) · pprior (θ, φ)

=
i=1

should specify how much each of these probabilities
is raised, based on the magnitude of θh ∈ R, the
class y, and the fact that the feature is an instance
of the template <Neg> . . . <Adjective>. (Thus, φ
has no parameters speciﬁc to the word gripping; it
is a low-dimensional vector that only describes the
annotator’s general style in translating θ into r.)
The language model, however, is independent of
the feature set θ. It models what rationales tend to
look like in the input domain—e.g., documents or
images. In the document case, φ should describe:
How frequent and how long are typical rationales?
Do their edges tend to align with punctuation or major syntactic boundaries in x? Are they rarer in the
middle of a document, or in certain documents?6
Thanks to the language model, we do not need to
posit high θ features to explain every word in a rationale. The language model can “explain away” some
words as having been highlighted only because this
annotator prefers not to end a rationale in midphrase, or prefers to sweep up close-together features with a single long rationale rather than many
short ones. Similarly, the language model can help
explain why some words, though important, might
not have been included in any rationale of r.
If there are multiple annotators, one can learn different φ parameters for each annotator, reﬂecting
their different annotation styles.7 We found this to
be useful (section 8.2).
We remark that our generative modeling approach
(equation (1)) would also apply if r were not rationale markup, but some other kind of so-called “side
information,” such as the feature annotations discussed in section 1. For example, Raghavan et al.
(2006) assume that if feature h is relevant—a bi6

Our current experiments do not model this last point. However, we imagine that if the document only has a few θ-features
that support the classiﬁcation, the annotator will probably mark
most of them, whereas if such features are abundant, the annotator may lazily mark only a few of the strongest ones. A simple
approach would equip φ with a different “bias” or “threshold”
parameter φx for each rationale training document x, to modulate the a priori probability of marking a rationale in x. By
ﬁtting this bias parameter, we deduce how lazy the annotator
was (for whatever reason) on document x. If desired, a prior
on φx could consider whether x has many strong θ-features,
whether the annotator has recently had a coffee break, etc.
7
Given insufﬁcient rationale data to recover some annotator’s φ well, one could smooth using data from other annotators.
But in our situation, φ had relatively few parameters to learn.

nary distinction—iff it was selected in at least one
document. But it might be more informative to observe that h was selected in 3 of the 10 documents
where it appeared, and to predict this via a model
pφ (3 of 10 | θh ), where φ describes (e.g.) how to derive a binomial parameter nonlinearly from θh . This
approach would not how often h was marked and infer how relevant is feature h (i.e., infer θh ). In this
case, pφ is a simple channel that transforms relevant
features into direct indicators of the feature. Our
side information merely requires a more complex
transformation—from relevant features into wellformed rationales, modulated by documents.

4

Experimental Data: Movie Reviews

In Zaidan et al. (2007), we introduced the “Movie
Review Polarity Dataset Enriched with Annotator
Rationales.”8 It is based on the dataset of Pang and
Lee (2004),9 which consists of 1000 positive and
1000 negative movie reviews, tokenized and divided
into 10 folds (F0 –F9 ). All our experiments use F9
as their ﬁnal blind test set.
The enriched dataset adds rationale annotations
produced by an annotator A0, who annotated folds
F0 –F8 of the movie review set with rationales (in the
form of textual substrings) that supported the goldstandard classiﬁcations. We will use A0’s data to
determine the improvement of our method over a
(log-linear) baseline model without rationales. We
also use A0 to compare against the “masking SVM”
method and SVM baseline of Zaidan et al. (2007).
Since φ can be tuned to a particular annotator, we
would also like to know how well this works with
data from annotators other than A0. We randomly
selected 100 reviews (50 positive and 50 negative)
and collected both class and rationale annotation
data from each of six new annotators A3–A8,10 following the same procedures as (Zaidan et al., 2007).
We report results using only data from A3–A5, since
we used the data from A6–A8 as development data
in the early stages of our work.
We use this new rationale-enriched dataset8 to determine if our method works well across annotators.
We will only be able to carry out that comparison
8

Available at http://cs.jhu.edu/∼ozaidan/rationales.
Polarity dataset version 2.0.
10
We avoid annotator names A1–A2, which were already
used in (Zaidan et al., 2007).
9

Figure 1: Rationales as sequence annotation: the annotator highlighted
two textual segments as rationales for
a positive class. Highlighted words in
x are tagged I in r, and other words
are tagged O. The ﬁgure also shows
some φ-features. For instance, gO(,)-I
is a count of O-I transitions that occur
with a comma as the left word. Notice
also that grel is the sum of the underlined values.

at small training set sizes, due to limited data from
A3–A8. The larger A0 dataset will still allow us to
evaluate our method on a range of training set sizes.

5
5.1

Detailed Models
Modeling class annotations with pθ

We deﬁne the basic classiﬁer pθ in equation (1) to be
a standard conditional log-linear model:
def

pθ (y | x) =

exp(θ · f (x, y)) def u(x, y)
=
Zθ (x)
Zθ (x)

(2)

where f (·) extracts a feature vector from a classiﬁed
document, θ are the corresponding weights of those
def
features, and Zθ (x) = y u(x, y) is a normalizer.
We use the same set of binary features as in previous work on this dataset (Pang et al., 2002; Pang
and Lee, 2004; Zaidan et al., 2007). Speciﬁcally, let
V = {v1 , ..., v17744 } be the set of word types with
count ≥ 4 in the full 2000-document corpus. Deﬁne
fh (x, y) to be y if vh appears at least once in x, and
0 otherwise. Thus θ ∈ R17744 , and positive weights
in θ favor class label y = +1 and equally discourage
y = −1, while negative weights do the opposite.
This standard unigram feature set is linguistically
impoverished, but serves as a good starting point for
studying rationales. Future work should consider
more complex features and how they are signaled by
rationales, as discussed in section 3.2.
5.2

Modeling rationale annotations with pφ

The rationales collected in this task are textual segments of a document to be classiﬁed. The document itself is a word token sequence x = x1 , ..., xM .

We encode its rationales as a corresponding tag sequence r = r1 , ..., rM , as illustrated in Figure 1.
Here rm ∈ {I, O} according to whether the token
xm is in a rationale (i.e., xm was at least partly highlighted) or outside all rationales. x1 and xM are
special boundary symbols, tagged with O.
We predict the full tag sequence r at once using
a conditional random ﬁeld (Lafferty et al., 2001). A
CRF is just another conditional log-linear model:
def

pφ (r | x, y, θ) =

exp(φ · g(r, x, y, θ)) def u(r, x, y, θ)
=
Zφ (x, y, θ)
Zφ (x, y, θ)

where g(·) extracts a feature vector, φ are the
corresponding weights of those features, and
def
Zφ (x, y, θ) = r u(r, x, y, θ) is a normalizer.
As usual for linear-chain CRFs, g(·) extracts two
kinds of features: ﬁrst-order “emission” features that
relate rm to (xm , y, θ), and second-order “transition” features that relate rm to rm−1 (although some
of these also look at x).
These two kinds of features respectively capture
the “channel model” and “language model” of section 3.2. The former says rm is I because xm is
associated with a relevant θ-feature. The latter says
rm is I simply because it is next to another I.
5.3

Emission φ-features (“channel model”)

Recall that our θ-features (at present) correspond to
unigrams. Given (x, y, θ), let us say that a unigram
w ∈ x is relevant, irrelevant, or anti-relevant if
y · θw is respectively
0, ≈ 0, or
0. That is, w
is relevant if its presence in x strongly supports the
annotated class y, and anti-relevant if its presence
strongly supports the opposite class −y.

Figure 2:
The
function family Bs
in equation (3),
shown for s ∈
{10, 2, −2, −10}.

We would like to learn the extent φrel to which
annotators try to include relevant unigrams in their
rationales, and the (usually lesser) extent φantirel to
which they try to exclude anti-relevant unigrams.
This will help us infer θ from the rationales.
The details are as follows. φrel and φantirel are the
weights of two emission features extracted by g:

5.4

M
def

its log-odds of being tagged with I, though not necessarily at the same rate as for relevant unigrams.12
Should φ also include traditional CRF emission features, which would recognize that particular
words like great tend to be tagged as I? No! Such
features would undoubtedly do a better job predicting the rationales and hence increasing equation (1).
However, crucially, our true goal is not to predict
the rationales but to recover the classiﬁer parameters θ. Thus, if great tends to be highlighted, then
the model should not be permitted to explain this
directly by increasing some feature φgreat , but only
indirectly by increasing θgreat . We therefore permit
our rationale prediction model to consider only the
two emission features grel and gantirel , which see the
words in x only through their θ-values.
Transition φ-features (“language model”)

Annotators highlight more than just the relevant unigrams. (After all, they aren’t told that our current
m=1
M
θ-features are unigrams.) They tend to mark full
def
gantirel (x, y, r, θ) =
I(rm = I) · B−10 (y · θxm ) phrases, though perhaps taking care to exclude antim=1
relevant portions. φ models these phrases’ shape, via
Here I(·) denotes the indicator function, returning weights for several “language model” features.
Most important are the 4 traditional CRF tag tran1 or 0 according to whether its argument is true or
false. Relevance and negated anti-relevance are re- sition features gO-O , gO-I , gI-I , gI-O . For example,
spectively measured by the differentiable nonlinear gO-I counts the number of O-to-I transitions in r
(see Figure 1). Other things equal, an annotator with
functions B10 and B−10 , which are deﬁned by
high φO-I is predicted to have many rationales per
Bs (a) = (log(1 + exp(a · s)) − log(2))/s (3) 1000 words. And if φI-I is high, rationales are predicted to be long phrases (including more irrelevant
and graphed in Figure 2. Sample values of B10 and unigrams around or between the relevant ones).
grel are shown in Figure 1.
We also learn more reﬁned versions of these feaHow does this work? The grel feature is a sum tures, which consider how the transition probabilover all unigrams in the document x. It does not ﬁre ities are inﬂuenced by the punctuation and syntax
strongly on the irrelevant or anti-relevant unigrams, of the document x (independent of θ). These resince B10 is close to zero there.11 But it ﬁres posi- ﬁned features are more speciﬁc and hence more
tively on relevant unigrams w if they are tagged with sparsely trained. Their weights reﬂect deviations
I, and the strength of such ﬁring increases approxi- from the simpler, “backed-off” transition features
mately linearly with θw . Since the weight φrel > 0 in such as gO-I . (Again, see Figure 1 for examples.)
practice, this means that raising a relevant unigram’s
θw (if y = +1) will proportionately raise its log- Conditioning on left word. A feature of the form
odds of being tagged with I. Symmetrically, since gt1 (v)-t2 is speciﬁed by a pair of tag types t1 , t2 ∈
φantirel > 0 in practice, lowering an anti-relevant un- {I, O} and a vocabulary word type v. It counts the
igram’s θw (if y = +1) will proportionately lower
12
grel (x, y, r, θ) =

11

I(rm = I) · B10 (y · θxm )

B10 sets the threshold for relevance to be about 0. One
could also include versions of the grel feature that set a higher
threshold, using B10 (y · θxm − threshold).

If the two rates are equal (φrel = φantirel ), we get a simpler
model in which the log-odds change exactly linearly with θw for
each w, regardless of w’s relevance/irrelevance/anti-relevance.
This follows from the fact that Bs (a) + B−s (a) simpliﬁes to a.

number of times an t1 –t2 transition occurs in r conditioned on v appearing as the ﬁrst of the two word
tokens where the transition occurs. Our experiments
include gt1 (v)-t2 features that tie I-O and O-I transitions to the 4 most frequent punctuation marks v
(comma, period, ?, !).
Conditioning on right word. A feature gt1 -t2 (v)
is similar, but v must appear as the second of the
two word tokens where the transition occurs. Again
here, we use gt1 -t2 (v) features that tie I-O and O-I
transitions to the four punctuation marks mentioned
above. We also include ﬁve features that tie O-I
transitions to the words no, not, so, very, and quite,
since in our development data, those words were
more likely than others to start rationales.13
Conditioning on syntactic boundary. We parsed
each rationale-annotated training document (no
parsing is needed at test time).14 We then marked
each word bigram x1 -x2 with three nonterminals:
NEnd is the nonterminal of the largest constituent
that contains x1 and not x2 , NStart is the nonterminal of the largest constituent that contains x2 and
not x1 , and NCross is the nonterminal of the smallest
constituent that contains both x1 and x2 .
For a nonterminal N and pair of tag types (t1 , t2 ),
we deﬁne three features, gt1 -t2 /E=N , gt1 -t2 /S=N ,
and gt1 -t2 /C=N , which count the number of times
a t1 -t2 transition occurs in r with N matching the
NEnd , NStart , or NCross nonterminal, respectively.
Our experiments include these features for 11 common nonterminal types N (DOC, TOP, S, SBAR,
FRAG, PRN, NP, VP, PP, ADJP, QP).

Training: Joint Optimization of θ and φ

6

To train our model, we use L-BFGS to locally maximize the log of the objective function (1):15
13

These are the function words with count ≥ 40 in a random
sample of 100 documents, and which were associated with the
O-I tag transition at more than twice the average rate. We do
not use any other lexical φ-features that reference x, for fear that
they would enable the learner to explain the rationales without
changing θ as desired (see the end of section 5.3).
14
We parse each sentence with the Collins parser (Collins,
1999). Then the document has one big parse tree, whose root is
DOC, with each sentence being a child of DOC.
15
One might expect this function to be convex because pθ and
pφ are both log-linear models with no hidden variables. However, log pφ (ri | xi , yi , θ) is not necessarily convex in θ.

n

log pθ (yi | xi ) −

1
2 θ
2σθ

log pφ (ri | xi , yi , θ)) −

1
2 φ
2σφ

i=1
n

+C(
i=1

2

2

(4)

This deﬁnes pprior from (1) to be a standard diago2
2
nal Gaussian prior, with variances σθ and σφ for the
2
two sets of parameters. We optimize σθ in our ex2
periments. As for σφ , different values did not affect
the results, since we have a large number of {I,O}
rationale tags to train relatively few φ weights; so
2
we simply use σφ = 1 in all of our experiments.
Note the new C factor in equation (4). Our initial experiments showed that optimizing equation (4)
without C led to an increase in the likelihood of the
rationale data at the expense of classiﬁcation accuracy, which degraded noticeably. This is because
the second sum in (4) has a much larger magnitude
than the ﬁrst: in a set of 100 documents, it predicts
around 74,000 binary {I,O} tags, versus the one
hundred binary class labels. While we are willing
to reduce the log-likelihood of the training classiﬁcations (the ﬁrst sum) to a certain extent, focusing
too much on modeling rationales (the second sum)
is clearly not our ultimate goal, and so we optimize
C on development data to achieve some balance between the two terms of equation (4). Typical values
1
1
of C range from 300 to 50 .16
We perform alternating optimization on θ and φ:
1. Initialize θ to maximize equation (4) but with
C = 0 (i.e. based only on class data).
2. Fix θ, and ﬁnd φ that maximizes equation (4).
3. Fix φ, and ﬁnd θ that maximizes equation (4).
4. Repeat 2 and 3 until convergence.
The L-BFGS method requires calculating the gradient of the objective function (4). The partial
derivatives with respect to components of θ and φ
involve calculating expectations of the feature functions, which can be computed in linear time (with
respect to the size of the training set) using the
forward-backward algorithm for CRFs. The partial derivatives also involve the derivative of (3),
to determine how changing θ will affect the ﬁring
strength of the emission features grel and gantirel .
16

C also balances our conﬁdence in the classiﬁcations y
against our conﬁdence in the rationales r; either may be noisy.

7

Experimental Procedures

We report on two sets of experiments. In the ﬁrst
set, we use the annotation data that A3–A5 provided
for the small set of 100 documents (as well as the
data from A0 on those same 100 documents). In
the second set, we used A0’s abundant annotation
data to evaluate our method with training set sizes up
to 1600 documents, and compare it with three other
methods: log-linear baseline, SVM baseline, and the
SVM masking method of (Zaidan et al., 2007).
7.1

Learning curves

The learning curves reported in section 8.1 are generated exactly as in (Zaidan et al., 2007). Each curve
shows classiﬁcation accuracy at training set sizes
T = 1, 2, ..., 9 folds (i.e. 200, 400, ..., 1600 training
documents). For a given size T , the reported accuracy is an average of 9 experiments with different
subsets of the entire training set, each of size T :
1
9

8

acc(F9 | Fi+1 ∪ . . . ∪ Fi+T )

(5)

i=0

where Fj denotes the fold numbered j mod 9, and
acc(F9 | Y ) means classiﬁcation accuracy on the
held-out test set F9 after training on set Y .
We use an appropriate paired permutation test, detailed in (Zaidan et al., 2007), to test differences in
(5). We call a difference signiﬁcant at p < 0.05.
7.2

Comparison to “masking SVM” method

We compare our method to the “masking SVM”
method of (Zaidan et al., 2007). Brieﬂy, that method
used rationales to construct several so-called contrast examples from every training example. A contrast example is obtained by “masking out” one of
the rationales highlighted to support the training example’s class. A good classiﬁer should have more
trouble on this modiﬁed example. Hence, Zaidan et
al. (2007) required the learned SVM to classify each
contrast example with a smaller margin than the corresponding original example (and did not require it
to be classiﬁed correctly).
The masking SVM learner relies on a simple geometric principle; is trivial to implement on top of an
existing SVM learner; and works well. However, we
believe that the generative method we present here is
more interesting and should apply more broadly.

Figure 3: Classiﬁcation accuracy curves for the 4 methods: the two baseline learners that only utilize class data,
and the two learners that also utilize rationale annotations. The SVM curves are from (Zaidan et al., 2007).

First, the masking method is speciﬁc to improving
an SVM learner, whereas our method can be used to
improve any classiﬁer by adding a rationale-based
regularizer (the second half of equation (4)) to its
objective function during training.
More important, there are tasks where it is unclear
how to generate contrast examples. For the movie
review task, it was natural to mask out a rationale
by pretending its words never occurred in the document. After all, most word types do not appear in
most documents, so it is natural to consider the nonpresence of a word as a “default” state to which we
can revert. But in an image classiﬁcation task, how
should one modify the image’s features to ignore
some spatial region marked as a rationale? There is
usually no natural “default” value to which we could
set the pixels. Our method, on the other hand, eliminates contrast examples altogether.

8

Experimental Results and Analysis

8.1

The added beneﬁt of rationales

Fig. 3 shows learning curves for four methods. A
log-linear model shows large and signiﬁcant improvements, at all training sizes, when we incorporate rationales into its training via equation (4).
Moreover, the resulting classiﬁer consistently outperforms17 prior work, the masking SVM, which
starts with a slightly better baseline classiﬁer (an
SVM) but incorporates the rationales more crudely.
17

Differences are not signiﬁcant at sizes 200, 1000, and 1600.

SVM baseline
SVM+contrasts
Log-linear baseline
Log-linear+rats
SVM baseline
SVM+contrasts
Log-linear baseline
Log-linear+rats

size
100
100
100
100
20
20
20
20

A0
72.0
75.0
71.0
76.0
63.4
65.4
63.0
65.8

A3
72.0
73.0
73.0
76.0
62.2
63.4
62.2
63.6

A4
72.0
74.0
71.0
77.0
60.4
62.4
60.2
63.4

A5
70.0
72.0
70.0
74.0
62.6
64.8
62.4
64.8

θA0
θA3
θA4
θA5

8.2

Analysis

Examining the learned weights φ gives insight into
annotator behavior. High weights include I-O and
O-I transitions conditioned on punctuation, e.g.,
φI(.)-O = 3.55,18 as well as rationales ending at the
end of a major phrase, e.g., φI-O/E=VP = 1.88.
The large emission feature weights, e.g., φrel =
14.68 and φantirel = 15.30, tie rationales closely to
θ values, as hoped. For example, in Figure 1, the
word w = succeeds, with θw = 0.13, drives up
p(I)/p(O) by a factor of 7 (in a positive document)
relative to a word with θw = 0.
In fact, feature ablation experiments showed that
almost all the classiﬁcation beneﬁt from rationales
can be obtained by using only these 2 emission
φ-features and the 4 unconditioned transition φfeatures. Our full φ (115 features) merely improves
our ability to predict the rationales (whose likelihood does increase signiﬁcantly with more features).
We also checked that annotators’ styles differ
enough that it helps to tune φ to the “target” annotator A who gave the rationales. Table 3 shows that a φ
model trained on A’s own rationales does best at predicting new rationales from A. Table 2 shows that as
18

When trained on folds F4 –F8 with A0’s rationales.

φA3
73.0
76.0
73.0
71.0

φA4
74.0
74.0
77.0
72.0

φA5
73.0
73.0
74.0
74.0

Baseline
71.0
73.0
71.0
70.0

Table 2: Accuracy rate for an annotator’s θ (rows) obtained when using some other annotator’s φ (columns).
Notice that the diagonal entries and the baseline column
are taken from rows of Table 1 (size=100).

Table 1: Accuracy rates using each annotator’s data. In a
given column, a value in italics is not signiﬁcantly different from the highest value in that column, which is boldfaced. The size=20 results average over 5 experiments.

To conﬁrm that we could successfully model annotators other than A0, we performed the same
comparison for annotators A3–A5; each had provided class and rationale annotations on a small 100document training set. We trained a separate φ for
each annotator. Table 1 shows improvements over
baseline, usually signiﬁcant, at 2 training set sizes.

φA0
76.0
73.0
75.0
74.0

−L(rA0 )
−L(rA3 )
−L(rA4 )
−L(rA5 )

φA0
0.073
0.084
0.088
0.058

φA3
0.086
0.068
0.084
0.044

φA4
0.077
0.071
0.075
0.047

φA5
0.088
0.068
0.085
0.044

Trivial
model
0.135
0.130
0.153
0.111

Table 3: Cross-entropy per tag of rationale annotations
r for each annotator (rows), when predicted from that
annotator’s x and θ via a possibly different annotator’s
φ (columns). For comparison, the trivial model is a bigram model of r, which is trained on the target annotator
but ignores x and θ. 5-fold cross-validation on the 100document set was used to prevent testing on training data.

a result, classiﬁcation performance on the test set is
usually best if it was A’s own φ that was used to help
learn θ from A’s rationales. In both cases, however,
a different annotator’s φ is better than nothing.

9

Conclusions

We have demonstrated a effective method for eliciting extra knowledge from naive annotators, in
the form of lightweight “rationales” for their annotations. By explicitly modeling the annotator’s
rationale-marking process, we are able to infer a better model of the original annotations.
We showed that our method performs signiﬁcantly better than two strong baseline classiﬁers,
and also outperforms our previous discriminative
method for exploiting rationales (Zaidan et al.,
2007). We also saw that it worked across four annotators who have different rationale-marking styles.
In future, we are interested in new domains that
can adaptively solicit rationales for some or all
training examples. Our new method, being essentially Bayesian inference, is potentially extensible to
many other situations—other tasks, classiﬁer architectures, and more complex features.

References
Eric Brill and Grace Ngai. 1999. Man [and woman] vs.
machine: A case study in base noun phrase learning.
In Proceedings of the 37th ACL Conference.
Michael Collins. 1999. Head-Driven Statistical Models
for Natural Language Parsing. Ph.D. thesis, University of Pennsylvania.
G. Druck, G. Mann, and A. McCallum. 2008. Learning from labeled features using generalized expectation criteria. In Proceedings of ACM Special Interest
Group on Information Retrieval, (SIGIR).
A. Haghighi and D. Klein. 2006. Prototype-driven learning for sequence models. In Proceedings of the Human Language Technology Conference of the NAACL,
Main Conference, pages 320–327, New York City,
USA, June. Association for Computational Linguistics.
John Lafferty, Andrew McCallum, and Fernando Pereira.
2001. Conditional random ﬁelds: Probabilistic models for segmenting and labeling sequence data. In Proceedings of the International Conference on Machine
Learning.
Grace Ngai and David Yarowsky. 2000. Rule writing
or annotation: Cost-efﬁcient resource usage for base
noun phrase chunking. In Proceedings of the 38th
Annual Meeting of the Association for Computational
Linguistics, pages 117–125, Hong Kong.
B. Pang and L. Lee. 2004. A sentimental education:
Sentiment analysis using subjectivity summarization
based on minimum cuts. In Proc. of ACL, pages 271–
278.
B. Pang, L. Lee, and S. Vaithyanathan. 2002. Thumbs
up? Sentiment classiﬁcation using machine learning
techniques. In Proc. of EMNLP, pages 79–86.
Hema Raghavan and James Allan. 2007. An interactive
algorithm for asking and incorporating feature feedback into support vector machines. In Proceedings of
SIGIR.
Hema Raghavan, Omid Madani, and Rosie Jones. 2006.
Active learning on both features and instances. Journal of Machine Learning Research, 7:1655–1686,
Aug.
Luis von Ahn, Ruoran Liu, and Manuel Blum. 2006.
Peekaboom: A game for locating objects. In CHI
’06: Proceedings of the SIGCHI Conference on Human Factors in Computing Systems, pages 55–64.
Omar Zaidan, Jason Eisner, and Christine Piatko. 2007.
Using “annotator rationales” to improve machine
learning for text categorization. In NAACL HLT 2007;
Proceedings of the Main Conference, pages 260–267,
April.

