Learning Fast-Mixing Models for Structured Prediction

Jacob Steinhardt
Percy Liang
Stanford University, 353 Serra Street, Stanford, CA 94305 USA

arXiv:1502.06668v1 [cs.LG] 24 Feb 2015

Abstract
Markov Chain Monte Carlo (MCMC) algorithms
are often used for approximate inference inside
learning, but their slow mixing can be difﬁcult to
diagnose and the approximations can seriously
degrade learning. To alleviate these issues, we
deﬁne a new model family using strong Doeblin Markov chains, whose mixing times can
be precisely controlled by a parameter. We
also develop an algorithm to learn such models,
which involves maximizing the data likelihood
under the induced stationary distribution of these
chains. We show empirical improvements on two
challenging inference tasks.

1. Introduction
Conventional wisdom suggests that rich features and
highly-dependent variables necessitate intractable inference. Indeed, the dominant paradigm is to ﬁrst deﬁne
a joint model, and then use approximate inference (e.g.,
MCMC) to learn that model. While this recipe can generate
good results in practice, it has two notable drawbacks: (i)
diagnosing convergence of Markov chains is extremely difﬁcult (Gelman and Rubin, 1992; Cowles and Carlin, 1996);
and (ii) approximate inference can be highly suboptimal
in the context of learning (Wainwright, 2006; Kulesza and
Pereira, 2007).
In this paper, we instead use MCMC to deﬁne the model
family itself: For a given T , we construct a family of
Markov chains using arbitrary rich features, but whose
mixing time is guaranteed to be at most O(T ). The corresponding stationary distributions make up the model family. We can think of our Markov chains as parameterizing a family of “computationally accessible” distributions,
where the amount of computation is controlled by T .

JSTEINHARDT @ CS . STANFORD . EDU
PLIANG @ CS . STANFORD . EDU

strong Doeblin chains (Doeblin, 1940):
˜
Aθ (yt | yt−1 , x) = (1 − )Aθ (yt | yt−1 , x) + uθ (yt | x),
(1)
where is a mixture coefﬁcient and θ parameterizes Aθ and
uθ . Importantly, uθ does not depend on the previous state
yt−1 . For intuition, think of uθ as a simple tractable model
and Aθ as Gibbs sampling in a complex intractable model.
With probability 1 − , we progress according to Aθ , and
with probability we draw a fresh sample from uθ , which
performs an informed random restart. When = 1, we
are drawing i.i.d. samples from uθ ; we therefore mix in a
single step, but our stationary distribution must necessarily
be very simple. When = 0, the stationary distribution can
be much richer, but we have no guarantees on the mixing
time. For intermediate values of , we trade off between
representational power and mixing time.
A classic result is that a given strong Doeblin chain mixes
in time at most 1 (Doeblin, 1940), and that we can draw an
exact sample from the stationary distribution in expected
time O( 1 ) (Corcoran and Tweedie, 1998). In this work, we
prove new results that help us understand the strong Doe˜
blin model families. Let F and F be the family of station˜
ary distributions corresponding to Aθ and Aθ as deﬁned in
(1), respectively. Our ﬁrst result is that as decreases, the
˜
stationary distribution of any Aθ monotonically approaches
the stationary distribution of the corresponding Aθ (as measured by either direction of the KL divergence). Our second result is that if 1 is much larger than the mixing time
˜
of Aθ , then the stationary distributions of Aθ and Aθ are
close under a certain Mahalanobis distance. This shows
that any member of F that is computationally accessible
via the Markov chain is well-approximated by its counter˜
part in F.
˜
F

F
F0

For concreteness, suppose we are performing a structured
prediction task from input x to a complex output y. We
construct Markov chains of the following form, called

˜
The ﬁgure above shows F and F, together with the subset

Learning Fast-Mixing Models for Structured Prediction
Stationary Probability vs. Restart Probability

˜
F0 of F whose Markov chains mix quickly. F (approximately) covers F0 , and contains some distributions outside
of F entirely.

We also generalize strong Doeblin chains, which are a mixture of two base chains, uθ and Aθ , to staged strong Doeblin chains, which allow us to combine more than two base
chains. We introduce an auxiliary variable z representing
the “stage” that the chain is in. We then transition between
stages, using the base chain corresponding to the current
stage z to advance the concrete state y. A common application of this generalization is deﬁning a sequence of
increasingly more complex chains, similar in spirit to annealing. This allows sampling to become gradually more
sensitive to the structure of the problem.
We evaluated our methods on two tasks: (i) inferring words
from ﬁnger gestures on a touch screen and (ii) inferring
DNF formulas for program veriﬁcation. Unlike many
structured prediction problems where local potentials provide a large fraction of the signal, in the two tasks above,
local potentials offer a very weak signal; reasoning carefully about the higher-order potentials is necessary to perform well. On word inference, we showed that learning
strong Doeblin chains obtained a 3.6% absolute improvement in character accuracy over Gibbs sampling while requiring 5x fewer samples. On DNF formula inference, our
staged strong Doeblin chain obtains an order of magnitude
speed improvement over plain Metropolis-Hastings.

2
1
3

2
3

δ
1

0.45
p(1)

˜
In order to learn over F, we show how to maximize the
likelihood of the data under the stationary distribution of
˜
Aθ . Speciﬁcally, we show that we can compute a stochastic
gradient of the log-likelihood in expected time O( 1 ). Thus,
in a strong sense, our objective function explicitly accounts
for computational constraints.

0.5

2δ

0.4

3
0.35

1−δ

1 − 2δ
0

10

−2

10

−4

ε

10

−6

10

Figure 1. Left: A simple 3-state Markov chain. Arcs denote transition probabilities. Right: plot of the stationary probability of state
1 as a function of restart probability , for δ = 10−4 . Note the two
regimes for
δ and
δ.

˜
In matrix notation, we can write A as
˜ def
A = (1 − )A + u1 .

(2)

In other words, with probability we restart from u; oth˜
erwise, we transition according to A. Intuitively, A should
mix quickly because a restart from u renders the past independent of the future (we formalize this in Section 3). We
think of u as a simple tractable model that provides coverage, and A as a complex model that provides precision.

To summarize, the contributions of this paper are: We formally deﬁne a family of MCMC algorithms based on strong
Doeblin chains with guaranteed fast mixing times (Section 2). We provide an extensive analysis of the theoretical
properties of this family (Section 3), together with a generalization to a staged version (Section 3.1). We provide an
algorithm for learning the parameters of a strong Doeblin
chain (Section 4). We demonstrate superior experimental
results relative to baseline MCMC samplers on two tasks,
word inference and DNF formula synthesis (Section 5).

Simple example. To gain some intuition, we work
through a simple example with the Markov chain A depicted in Figure 1. The stationary distribution of this chain
1
3δ
1
is 2+3δ 2+3δ 2+3δ , splitting most of the probability mass evenly between states 1 and 3. The mixing time
of this chain is approximately 1 , since once the chain falls
δ
into either state 1 or state 3, it will take about 1 steps for it
δ
to escape back out. If we run this Markov chain for T steps
1
with T
δ , then our samples will be either almost all in
state 1 or almost all in state 3, and thus will provide a poor
summary of the distribution. If instead we perform random restarts with probability from a uniform distribution
u over {1, 2, 3}, then the restarts give us the opportunity
to explore both modes of the distribution. After a restart,
however, the chain will more likely fall into state 3 than
state 1 ( 5 probability vs. 4 ), so for
δ the stationary
9
9
distribution will be noticeably perturbed by the restarts. If
δ, then there will be enough time for the chain to mix
between restarts, so this bias will vanish. See Figure 1 for
an illustration of this phenomenon.

2. A Fast-Mixing Family of Markov Chains

3. Theoretical Properties

Given a Markov chain with transition matrix A(yt | yt−1 )
and a distribution u(yt ), deﬁne a new Markov chain with
def
˜
transitions given by A(yt | yt−1 ) = (1 − )A(yt | yt−1 ) +
u(yt ). (We suppress the dependence on θ and x for now.)

Markov chains that can be expressed according to (2) are
said to have strong Doeblin parameter (Doeblin, 1940).
In this section, we characterize the stationary distribution
˜
and mixing time of A, and also relate the stationary distri˜
bution of A to that of A as a function of . Often the easiest
˜
way to study the mixing time of A is via its spectral gap,

Learning Fast-Mixing Models for Structured Prediction

˜
˜
which is deﬁned as 1 − λ2 (A), where λ2 (A) is the secondlargest eigenvalue (in complex norm). A standard result for
Markov chains is that, under mild assumptions, the mixing
˜
time of A is O 1−λ1 (A) . We assume throughout this sec˜
2
tion that A is ergodic but not necessarily that it is reversible.
See Section 12.4 of Levin et al. (2009) for more details.
Our ﬁrst result relates the spectral gap (and hence the mixing time) to . This result (as well as the next) are wellknown but we include them for completeness. For most
results in this section, we sketch the proof here and provide
the full details in the appendix.
˜
Proposition 3.1. The spectral gap of A is at least ; that
˜
˜
is, 1 − λ2 (A) ≥ . In particular, A mixes in time O( 1 ).
˜
The key idea is that all eigenvectors of A and A (except
˜
for the stationary distribution) are equal, and that λk (A) =
(1 − )λk (A) for k > 1.
˜
Having established that A mixes quickly, the next step is to
determine its stationary distribution:
˜
Proposition 3.2. Let π be the stationary distribution of A.
˜
Then
∞

(1 − )j Aj u = (I − (1 − )A)−1 u.

π=
˜

(3)

j=0

This can be directly veriﬁed algebraically. The summation over j shows that we can in fact draw an exact sample
from π by drawing T ∼ Geometric( ),1 initializing from
˜
u, and transitioning T times according to A. This is intuitive, since at a generic point in time we expect the most
recent sample from u to have occurred Geometric( ) steps
ago. Note that E[T + 1] = 1 , which is consistent with the
fact that the mixing time is O( 1 ) (Proposition 3.1).
We would like to relate the stationary distributions π and π
˜
˜
of A and A. The next two results (which are new) do so.
˜
Let π denote the stationary distribution of A at a particular
˜
value of ; note that π1 = u and π0 = π. We will show that
˜
˜
π approaches π monotonically, for both directions of the
˜
KL divergence. In particular, for any < 1, π is at least as
˜
good as u at approximating π.

2

u

A

u

1−

A1

A2

1

1

1−

1−

1

1−

2

Figure 2. Markov chains over (a) two stages (strong Doeblin
chains); and (b) three stages (restart from u followed by transitions from A1 and then from A2 ).

Proposition 3.4. Both KL (˜
π
monotonic functions of .

π) and KL (π

π ) are
˜

The idea is to construct a transition matrix B that maps
π 1 to π 2 for given 2 < 1 , then show that its stationary
˜
˜
distribution is π and apply Lemma 3.3.
With Proposition 3.4 in hand, a natural next question is how
small must be before π is reasonably close to π. Propo˜
sition 3.5 provides one such bound: π is close to π if is
˜
small compared to the spectral gap 1 − λ2 (A).
Proposition 3.5. Suppose that A satisﬁes detailed balance
˜
with respect to π. Let π be the stationary distribution of A.
˜
def

2

(y)
−1 + y ππ(y) ,
√
where v M is the Mahalonobis distance v M v. Then
dπ (˜ ) ≤ 1−λ2 (A) · dπ (u). (In particular, dπ (˜ )
π
π
1 if
(1 − λ2 (A))/dπ (u).)

Deﬁne dπ (π ) = π −π

diag(π)−1

=

The proof is somewhat involved, but the key step is to establish that dπ (π ) is convex in π and contractive with respect to A (more precisely, that dπ (Aπ ) ≤ λ2 (A)dπ (π )).
˜
Proposition 3.5 says that if A mixes quickly, then A and A
will have similar stationary distributions. This serves as a
sanity check: if A already mixes quickly, then π is a good
˜
approximation to π; otherwise, the Doeblin construction
ensures that we are at least converging to some distribution,
which by Proposition 3.4 approximates π at least as well as
u does.
3.1. Staged strong Doeblin chains

Using this lemma, we can prove the following monotonicity result:

˜
Recall that to run a strong Doeblin chain A, we ﬁrst sample from u, and then transition according to A for approximately 1 steps. The intuition is that sampling from the
crude distribution u faciliates global exploration of the state
space, while the reﬁned transition A hones in on a mode.
However, for complex problems, there might be a considerable gap between what is possible with exact inference (u)
and what is needed for accurate modeling (A). This motivates using multiple stages of MCMC to bridge the gap.

1
If T ∼ Geometric( ), we have P[T = j] = (1 − )j for
j ≥ 0.

To do this, we introduce an auxiliary variable z ∈ Z denoting which stage of MCMC we are currently in. For each

To show this, we make use of the following lemma from
Murray and Salakhutdinov (2008):
Lemma 3.3. If B is a transition matrix with stationary
distribution π, then KL (π Bπ ) ≤ KL (π π ) and
KL (Bπ π) ≤ KL (π π).

Learning Fast-Mixing Models for Structured Prediction

stage z, we have a Markov chain Az (yt | yt−1 ) over the
original state space. We also deﬁne a Markov chain C(zt |
zt−1 ) over the stages. To transition from (yt−1 , zt−1 ) to
(yt , zt ), we ﬁrst sample zt from C(zt | zt−1 ) and then
yt from Azt (yt | yt−1 ). If there is a special state z ∗ for
which Az∗ (yt | yt−1 ) = u(yt ) (i.e., Az∗ does not depend
on yt−1 ), then we call the resulting chain a staged strong
Doeblin chain.
For example, if z ∈ {0, 1} and we transition from 0 to 1
with probability 1 − and from 1 to 0 with probability ,
then we recover strong Doeblin chains assuming z ∗ = 0
(Figure 2(a)). As another example (Figure 2(b)), let z ∈
{0, 1, 2}. When z = z ∗ = 0, transition according to a
restart distribution u1 ; when z = 1, transition according
to a simple chain A1 ; and when z = 2 transition according
to a more complex chain A2 . If we transition from z = 0
to z = 1 with probability 1, from z = 1 to z = 2 with
probability 1 , and from z = 2 to z = 0 with probability 2 ,
then we will on average draw 1 sample from u, 1 samples
1
from A1 , and 1 samples from A2 .
2
We now show that staged strong Doeblin chains mix
quickly as long as we visit z ∗ reasonably often. In particular, the following theorem provides guarantees on the
mixing time that depend only on z ∗ and on the structure of
C(zt | zt−1 ), analogous to the previous dependence only
on . The condition of the theorem asks for times a and b
such that the ﬁrst time after a that we hit z ∗ is almost independent of the starting state z0 , and is less than b with high
probability.
Theorem 3.6. Let M be a staged strong Doeblin chain on
Z × Y. Let τa be the earliest time s ≥ a for which zs =
def
z ∗ . Let βa,s = minz∈Z P[τa = s | z0 = z] and γa,b =
b
b
s=a βa,s . Then M has strong Doeblin parameter γa,b .
γ
In particular, the spectral gap of M is at least a,b . (Setting
b
a = b = 1 recovers Proposition 3.1.)
The key idea is that, conditioned on τa , (yb , zb ) is independent of (y0 , z0 ) for all b ≥ τa . For the special case that the
stages form a cycle as in Figure 2, we have the following
corollary:
Corollary 3.7. Let C be a transition matrix on {0, . . . , k −
1} such that C(zt = i | zt−1 = i) = 1 − δi and C(zt =
(i + 1) mod k | zt−1 = i) = δi . Suppose that δk−1 ≤
1
max(2,k−1) min{δ0 , . . . , δk−2 }. Then the spectral gap of
the joint Markov chain is at least

δk−1
78 .

The key idea is that, when restricting to the time interval
[2/δk−1 , 3/δk−1 ], the time of ﬁrst transition from k − 1 to
0 is approximately Geometric(δk−1 )-distributed (independent of the initial state), which allows us to invoke Theorem 3.6. We expect the optimal constant to be much smaller
than 78.

4. Learning strong Doeblin chains
Section 3 covered properties of strong Doeblin chains (1 −
)Aθ + uθ 1 for a ﬁxed parameter vector θ. Now we turn
to the problem of learning θ from data. We will focus on the
discriminative learning setting where we are given a dataset
{(x(i) , y (i) )}n and want to maximize the conditional logi=1
likelihood:
O(θ) =

1
n

n

log pθ (y (i) | x(i) ),

(4)

i=1

˜
where now pθ is the stationary distribution of Aθ = (1 −
)Aθ + uθ 1 . We assume for simplicity that the chains
Aθ and uθ are given by conditional exponential families:
def

Aθ (y | y , x) = exp θ φ(x, y , y) − log Z(θ; x, y) ,
def

uθ (y | x) = exp θ φ(x, y) − log Z(θ; x) ,

(5)

where each φ outputs a feature vector and the Z are parti˜
tion functions. By Proposition 3.1, Aθ mixes quickly for all
θ. On the other hand, the parameterization of Aθ captures a
rich family of transition kernels, including Gibbs sampling.
At a high level, our learning algorithm performs stochastic gradient descent on the negative log-likelihood. However, the negative log-likelihood is only deﬁned implicitly
in terms of the stationary distribution of a Markov chain,
so the main challenge is to show that it can be computed
efﬁciently. To start, we assume that we can operate on the
base chains uθ and Aθ for one step efﬁciently:
Assumption 4.1. We can efﬁciently sample y from uθ (· |
uθ
x) and Aθ (· | y , x), as well as compute ∂ log ∂θ (y|x) and
∂ log Aθ (y|y ,x)
.
∂θ

Under Asssumption 4.1, we will show how to efﬁciently
compute the gradient of log pθ (y (i) | x(i) ) with respect to
θ. The impatient reader may skip ahead to the ﬁnal pseudocode, which is given in Algorithm 1.
For convenience, we will suppress the dependence on x and
i and just refer to pθ (y) instead of pθ (y (i) | x(i) ). Computing the gradient of log pθ (y) is non-trivial, since the formula for pθ is somewhat involved:
∞

(1 − )j [Aj uθ ](y).
θ

pθ (y) =

(6)

j=0

We are helped by the following generic identity on gradients of conditional log-probabilities, proved in the appendix.
Lemma 4.2. Let z have distribution pθ (z) parameterized
by a vector θ. Let S be any measurable set. Then
∂ log pθ (z ∈ S)
∂ log pθ (z)
= Ez
z∈S .
∂θ
∂θ

(7)

Learning Fast-Mixing Models for Structured Prediction

We can utilize Lemma 4.2 by interpreting y | θ as the output of the following generative process, which by Proposi˜
tion 3.2 yields the stationary distribution of Aθ :
• Sample y0 from uθ and yt+1 | yt from Aθ for t =
0, 1, . . ..
• Sample T ∼ Geometric( ) and let y = yT .
We then invoke Lemma 4.2 with z = (T, y0:T ) and S encoding the event that yT = y. As long as we can sample
from the posterior distribution of (T, y0:T ) conditioned on
∂
yT = y, we can compute an estimate of ∂θ log pθ (y) as
follows:
• Sample (T, y0:T ) | yT = y.
• Return

∂ log pθ (T,y0:T )
∂θ

uθ
= ∂ log∂θ (y0 )
T
(y
+ t=1 ∂ log Aθ∂θ t |yt−1 ) .

4.1. Sampling schemes for (T, y0:T )

+

By the preceding comments, it sufﬁces to construct a sampler for (T, y0:T ) | yT = y. A natural approach is to use
importance sampling: sample (T, y0:T −1 ), then weight by
p(yT = y | yT −1 ). However, this throws away a lot of
work — we make T MCMC transitions but obtain only one
sample (T, y0:T ) with which to estimate the gradient.
We would like to ideally make use of all the MCMC transitions when constructing our estimate of (T, y0:T ) | yT = y.
For any t ≤ T , the pair (t, y0:t ) would itself have been
a valid sample under different randomness, and we would
like to exploit this. Suppose that we sample T from some
distribution F and let q(t) be the probability that T ≥ t
under F . Then we can use the following scheme:
• Sample T from F , then sample y0:T −1 .
• For t = 0, . . . , T , weight (t, y0:t−1 ) by
p(yt = y | yt−1 ).

Algorithm 1 Algorithm for computing an estimate of
∂
∂θ log pθ (y | x). This estimate is unbiased in the limit
of inﬁnitely many samples k, but will be biased for a ﬁnite
number of samples due to variance in the estimate of the
partition function.
SampleGradient(x, y, θ, , k)
£ k is the number of samples to take
Z ← 0; g ← 0 £ Z is the total importance mass of all
g
samples, Z is the gradient
for i = 1 to k do
Sample T ∼ Geometric( )
Sample y0 from uθ (· | x)
For 1 ≤ t ≤ T −1: sample yt fromAθ (· | yt−1 , x)
w0 ← · uθ (y)
For 1 ≤ t ≤ T : wt ← · Aθ (y | yt−1 , x)
T
Z ← Z + t=0 wt
uθ
g ← g + w0 ∂ log ∂θ (y|x)

(1− )t
q(t)

+

T
t=1

wt

∂ log uθ (y0 |x)
∂θ

t−1 ∂ log Aθ (ys |ys−1 ,x)
(y|y
+ ∂ log Aθ ∂θ t−1 ,x)
s=1
∂θ

.

end for
g
Output Z

At a high level, we can just use Algorithm 1 to compute
estimates of the gradient and then apply an online learning
algorithm such as A DAG RAD (Duchi et al., 2011) to identify a good choice of θ. Since the log-likelihood is a nonconvex function of θ, the initialization is important. We
make the following (weak) assumption:
Assumption 4.3. The chains uθ and Aθ are controlled by
disjoint coordinates of θ, and for any setting of uθ there is
a corresponding choice of Aθ that leaves uθ invariant (i.e.,
Aθ uθ = uθ ).

×

For any q, this yields unbiased (although unnormalized)
weights (see Section B in the appendix). Typically we will
choose q(t) = (1 − )t , e.g. F is a geometric distribution. If the yt are perfectly correlated, this will not be
any more effective than vanilla importance sampling, but
in practice this method should perform substantially better. Even though we obtain weights on all of y0:T , these
weights will typically be highly correlated, so we should
still repeat the sampling procedure multiple times to minimize the bias from estimating the normalization constant.
The full procedure is given as pseudocode in Algorithm 1.

In practice, Assumption 4.3 is easy to satisfy. For instance, suppose that φ : Y → Rd is a feature function, θ = [θ0 θ1 ] ∈ Rd0 +d are the features controlling
u and A, and uθ0 is made tractable by zeroing some features out: uθ0 (y) ∝ exp([θ0 0d−d0 ] φ(y)). Also suppose that Aθ1 is a Gibbs sampler that uses all the features:
Aθ1 (y | y ) ∝ exp(θ1 φ(yi , y¬i )), where i is a randomly
chosen coordinate of y. Then, we can satisfy Assumption 4.3 by setting θ1 = [θ0 0d−d0 ].

4.2. Implementation

Under Assumption 4.3, we can initialize θ by ﬁrst training
u in isolation (which is a convex problem if uθ parameterizes an exponential family), then initializing A to leave u
invariant; this guarantees that the initial log-likelihood is
what we would have obtained by just using u by itself. We
found this to work well empirically.

With the theory above in place, we now describe some important implementation details of our learning algorithm.

As another note, Algorithm 1 na¨vely looks like it takes
ı
O(T 2 ) time to compute the gradient for each sample, due

Learning Fast-Mixing Models for Structured Prediction

q

w
a

e
s

z

r
d

x

t
f

c

y
g

v

u
h

b

i

o

j

k

n

p
l

m

x:

b d s a d b n n n f a a s s j j j

z:

b # # a # # n-n-n # a-a # # n-n a

y:

b

a

n

a

n

a

Figure 3. Generated sequence of keyboard gestures for the word
banana. The input x is a sequence of characters (the recorded key
presses), and the output y is the intended word. Most characters
in x are incidental and do not correspond to any character in y;
this is reﬂected by the (unobserved) alignment z.

to the nested sum. However, most terms are of the form
wt ∂ log Aθ (ys |ys−1 ,x) ; by grouping them for a ﬁxed s we
∂θ
can compute the sum in O(T ) time, leading to expected
runtime O k for Algorithm 1 (since E[T + 1] = 1 ).

5. Experiments
We validated our method on two challenging inference
tasks. These tasks are difﬁcult due to the importance of
high-arity factors; local information is insufﬁcient to even
identify high-probability regions of the space.
Inferring Words from Keyboard Gestures We ﬁrst
considered the task of inferring words from keyboard gestures. We generated the data by sampling words from the
New York Times corpus (Sandhaus, 2008). For each word,
we used a time series model to synthetically generate ﬁnger gestures for the word. A typical instantiation of this
process is given in Figure 3. The learning task is to discriminatively infer the intended word y given the sequence
of keys x that the ﬁnger was over (for instance, predicting
banana from bdsadbnnnfaassjjj). In our model,
we posit a latent alignment z between key presses and intended letter. Given an input x of length l, the alignment z
also has length l; each zi is either ‘c’ (xi starts an output
letter c), ‘-c’ (xi continues an output letter c), or ‘#’ (xi is
unaligned); see Figure 3 for an example. Note that y is a
deterministic function of z.
The base model uθ consists of indicator features on (xi , zi ),
(xi , zi−1 , zi ), and (xi , xi−1 , zi ). The full Aθ is a Gibbs
sampler in a model where we include the following features
in addition to those above:
• indicator features on (xi , yi , yi−1 )
• indicator of y being in the dictionary, as well as log of
word frequency (conditioned on being in the dictionary)
• for each i, indicator of y1:i matching a preﬁx of a word
in the dictionary

We compared three approaches:
• Our approach (Doeblin sampling)
• Regular Gibbs sampling, initialized by setting zi = xi
for all i (basic-Gibbs)
• Gibbs sampling initialized from uθ (uθ -Gibbs)
At test time, all three of these methods are almost identical: they all initialize from some distribution, then make
a certain number of Gibbs samples. For basic-Gibbs and
uθ -Gibbs, this is always a ﬁxed number of steps T , while
for Doeblin sampling the number of steps is a geometric
distribution with mean T .
The main difference is in how the methods are trained. Our
method is trained using the ideas in Section 4; for the other
two methods, we train by approximating the gradient:
log pθ (y | x) = Ez∼pθ (z|x,y) [φ(y, z , x)]
ˆ
ˆ
− Ey,ˆ∼pθ (y,z|x) [φ(ˆ, z , x)],
y ˆ
ˆz
where φ(y, z, x) is the feature function and pθ is the stationary distribution of Aθ . For the second term, we use
MCMC samples from Aθ to approximate pθ (y, z | x).
For the ﬁrst term, we could take the subset of samples
where y = y, but this is problematic if no such samples
ˆ
exist. Instead, we reweight all samples with y = y by
ˆ
exp(−(D+1)), where D is the edit distance between y and
y . We use the same reweighting approach for the Doeblin
ˆ
sampler, using this as the importance weight rather than using Aθ (y | yt−1 ) as in Algorithm 1.

To provide a fair comparison of the methods, we set in the
Doeblin sampler to the inverse of the number of transitions
T , so that the expected number of transitions of all algorithms is the same. We also devoted the ﬁrst half of each
chain to burn-in.
All algorithms are trained with AdaGrad (Duchi et al.,
2011) with 16 independent chains run for each example.
We measure word-level accuracy by computing the fraction of (non-burn-in) samples whose output y is correct.
The results are reported in Figure 4. Overall, our Doeblin sampler outperforms uθ -Gibbs by a signiﬁcant margin, which in turn outperforms basic-Gibbs. Interestingly,
while the accuracy of our method continues to improve
with more training time, uθ -Gibbs quickly asymptotes and
then slightly decreases, even for training accuracy.
What is happening to uθ -Gibbs? Since the inference problem in this task is hard, the samples provide a poor gradient
approximation. As a result, optimization methods that take
the approximation at face value may not converge to even
a local optimum. This phenomenon has already been studied in other contexts, for instance by Kulesza and Pereira

Learning Fast-Mixing Models for Structured Prediction

Train

Test
0.25

0.20

0.20

accuracy

0.30

0.25

accuracy

0.30

0.15
0.10

0.15
0.10

0.05
0.00
0.0

5

Doeblin (20)
uθ-Gibbs (20)
basic (20)

100.2 15

0.4
5

Doeblin (20)
Doeblin (50)
Doeblin (100)
0.6
10 15

uθ-Gibbs (20)
uθ-Gibbs (50)
uθ-Gibbs (100)

5

0.810

15

0.05
1.0

training passes training passes training passes

0.00
0.0

5

Doeblin (20)
uθ-Gibbs (20)
basic (20)

100.2 15

0.4
5

Doeblin (20)
Doeblin (50)
Doeblin (100)
0.6
10 15

uθ-Gibbs (20)
uθ-Gibbs (50)
uθ-Gibbs (100)

5

0.810

15

1.0

training passes training passes training passes

Figure 4. Plots of word-level (left) and character-level (right) accuracy. The ﬁrst panel gives the performance of all 3 methods (Doeblin
chains, smart restarts, and simple Gibbs) for a computational budget of 20 transitions per example. The second and third panels give the
performance of Doeblin chains and smart restarts, respectively, for increasing computational budgets (20, 50, and 100 transitions).

(2007) and Huang et al. (2012).

a formula.

In contrast, our method directly optimizes the loglikelihood of the data under the distribution πθ , so that ac˜
curacy continues to increase with more passes through the
training data. This demonstrates that the MCMC samples
do provide enough signal to train from, but that na¨vely
ı
plugging them into a method designed for exact inference
will fail to exploit that signal.

The search space for this problem is extremely large. Even
if we set n = m = 3 and restrict our search to aij ∈
{−1, 0, 1}5 , b ∈ {−1, 0, 1}, the total number of candidate
3×3
formulae is still 36
≈ 5.8 × 1025 .

Inferring DNF Formulas We next study the use of our
staged Doeblin chain construction as a tool for hierarchical
initialization. We ignore learning for now, instead treating MCMC as a stochastic search algorithm. Our task
of interest is to infer a DNF formula f from its inputoutput behavior. This is an important subroutine in loop
invariant synthesis, where MCMC methods have recently
shown great promise (Gulwani and Jojic, 2007; Sharma and
Aiken, 2014).
Concretely, the input x might look like this:
f (1, 2, 3) = True
f (1, 4, 4) = True
f (0, 1, 0) = False
f (0, 2, 2) = True
Our task is to reconstruct f ; in this case, f (x1 , x2 , x3 ) =
[x1 = 0] ∨ [x2 = x3 ].
More formally, we consider DNF formulae with linear inn
m
equality predicates: f (x) =
i=1 j=1 [aij x ≤ bij ],
d
where aij , x ∈ Z and bij ∈ Z. The formula f maps input
vectors to {True, False}. Given a collection of example
inputs and outputs, our goal is to ﬁnd an f consistent with
all examples. Our evaluation metric is the time to ﬁnd such

We consider three MCMC methods: no restarts (0-stage),
uniformly random restarts (1-stage), and a staged method
(2-stage) as in Section 3.1. All base chains perform
Metropolis-Hastings using proposals that edit individual
atoms (e.g., [aij x ≤ bij ]), either by changing a single entry
of [aij bij ] or by changing all entries of [aij bij ] at once.
For the staged method, we initialize uniformly at random,
then take Geometric(0.04) transitions based on a simpliﬁed cost function, then take Geometric(0.0002) steps with
the full cost (this is the staged Doeblin chain in Figure 2).
The full cost function is I(f ), the number of examples f
errs on. We stop the Markov chain when it ﬁnds a formula
with I(f ) = 0. The simpliﬁed cost function decomposes
over the disjuncts: for each disjunct d(x), if f (x) = False
while d(x) = True, we incur a large cost (since in order for
f (x) to be false, all disjuncts comprising f (x) must also be
false). If f (x) = True while d(x) = False, then we incur
a smaller cost. If f (x) = d(x) then we incur no cost.
We used all three methods as a subroutine in verifying
properties of C programs; each such veriﬁcation requires
solving many instances of DNF formula inference. Using
the staged method we are able to obtain a 30% speedup
over uniformly random restarts and a 50x improvement
over no restarts, as shown in Table 1.

Learning Fast-Mixing Models for Structured Prediction
Table 1. Comparison of 3 different MCMC algorithms. 0-stage uses no restarts, 1-stage uses random restarts, and 2-stage uses random
restarts followed by a short period of MH with a simpliﬁed cost function. The table gives mean time and standard error (in seconds)
taken to verify 5 different C programs, for 1000 trials. Each veriﬁcation requires inferring many DNF formulae as a sub-routine.

Task
0-stage
1-stage
2-stage

ﬁg1
2.6 ± 1.0
0.074 ± 0.001
0.055 ± 0.005

cegar2
320 ± 9.3
0.41 ± 0.01
0.33 ± 0.007

nested
120 ± 7.0
2.4 ± 0.10
2.3 ± 0.12

tacas06
≥ 600
6.8 ± 0.15
4.6 ± 0.12

hard
≥ 600
52 ± 1.5
31 ± 0.90

6. Discussion

distribution.

We have proposed a model family based on strong Doeblin Markov chains, which guarantee fast mixing. Our
construction allows us to simultaneously leverage a simple, tractable model (uθ ) that provides coverage together
with a complex, accurate model (Aθ ) that provides precision. As such, we sidestep a typical dilemma—whether to
use a simple model with exact inference, or to deal with the
consequences of approximate inference in a more complex
model.

Our staged Doeblin construction belongs to the family of
coarse-to-ﬁne inference methods, which operate on progressively more complex models (Viola and Jones, 2004;
Shen et al., 2004; Collins and Koo, 2005; Charniak et al.,
2006; Carreras et al., 2008; Gu et al., 2009; Weiss et al.,
2010; Sapp et al., 2010; Petrov, 2011; Yadollahpour et al.,
2013).

While our approach works well in practice, there are still
some outstanding issues. One is the non-convexity of the
learning objective, which makes the procedure dependent
on initialization. Another issue is that the gradients returned by Algorithm 1 can be large, heterogeneous, and
high-variance. The adaptive nature of A DAG RAD alleviates this somewhat, but it would still be ideal to have a sampling procedure that had lower variance than Algorithm 1.
Though Gibbs sampling is the de facto method for many
practitioners, there are also many more sophisticated approaches to MCMC (Green, 1995; Earl and Deem, 2005).
Since our framework is orthogonal to the particular choice
of transition kernel, it would be interesting to apply our
method in these contexts.
Finally, we would like to further explore the staged construction from Section 3.1. As the initial results on DNF
formula synthesis are promising, it would be interesting to
apply the construction to high-dimensional feature spaces
as well as rich, multi-level hierarchies. We believe this
might be a promising approach for extremely rich models
in which a single level of re-initialization is insufﬁcient to
capture the complexity of the cost landscape.

On the theoretical front, we make use of the well-developed
theory of strong Doeblin chains, often also referred to
with the terms minorization or regeneration time (Doeblin, 1940; Roberts and Tweedie, 1999; Meyn and Tweedie,
1994; Athreya and Ney, 1978). The strong Doeblin property is typically used to study convergence of continuousspace Markov chains, but Rosenthal (1995) has used it
to analyze Gibbs sampling, and several authors have provided algorithms for sampling exactly from arbitrary strong
Doeblin chains (Propp and Wilson, 1996; Corcoran and
Tweedie, 1998; Murdoch and Green, 1998). We are the
ﬁrst to use strong Doeblin properties to construct model
families and learn them from data.

At a high level, our idea is to identify a family of
models for which an approximate inference algorithm is
known to work well, thereby constructing a computationally tractable model family that is nevertheless more expressive than typical tractable families such as low-treewidth graphical models. We think this general program is
very interesting, and could be applied to other inference
algorithms as well, thus solidfying the link between statistical theory and practical reality.

References
Related work. Our learning algorithm is reminiscent of
policy gradient algorithms in reinforcement learning (Sutton et al., 2000), as well as Searn, which tries to learn an
optimal search policy for structured prediction (Daum´ III
e
et al., 2009); see also Shi et al. (2015), who apply reinforcement learning in the context of MCMC. Our staged
construction is also similar in spirit to path sampling (Gelman and Meng, 1998), as it uses a multi-stage approach to
smoothly transition from a very simple to a very complex

KB Athreya and P Ney. A new approach to the limit theory
of recurrent Markov chains. Transactions of the AMS,
1978.
Xavier Carreras, Michael Collins, and Terry Koo. Tag,
dynamic programming, and the perceptron for efﬁcient,
feature-rich parsing. In CoNLL, 2008.
E Charniak, M Johnson, M Elsner, J Austerweil, D Ellis,

Learning Fast-Mixing Models for Structured Prediction

I Haxton, C Hill, R Shrivaths, J Moore, M Pozar, et al.
Multilevel coarse-to-ﬁne PCFG parsing. In NAACL,
2006.

Alex Kulesza and Fernando Pereira. Structured learning
with approximate inference. In Advances in neural information processing systems, pages 785–792, 2007.

Michael Collins and Terry Koo. Discriminative reranking
for natural language parsing. Computational Linguistics,
31(1):25–70, 2005.

DA Levin, Y Peres, and EL Wilmer. Markov chains and
mixing times. 2009.

JN Corcoran and RL Tweedie. Perfect sampling of Harris
recurrent Markov chains. preprint, 1998.
MK Cowles and BP Carlin. Markov chain Monte Carlo
convergence diagnostics: a comparative review. Journal
of the American Statistical Association, 1996.
H Daum´ III, J Langford, and D Marcu. Search-based
e
structured prediction. Machine learning, 2009.
W Doeblin. Elements d’une theorie generale des chaines
simples constantes de markoff. In Annales scientiﬁques
´
de l’Ecole Normale Sup´ rieure, volume 57, pages 61–
e
111. Soci´ t´ math´ matique de France, 1940.
ee
e
J Duchi, E Hazan, and Y Singer. Adaptive subgradient
methods for online learning and stochastic optimization.
Journal of Machine Learning Research, pages 2121–
2159, 2011.
David J Earl and Michael W Deem. Parallel tempering:
Theory, applications, and new perspectives. Physical
Chemistry Chemical Physics, 7(23):3910–3916, 2005.
A Gelman and XL Meng. Simulating normalizing constants: From importance sampling to bridge sampling to
path sampling. Statistical science, 1998.
A Gelman and DB Rubin. A single series from the Gibbs
sampler provides a false sense of security. Bayesian
statistics, 1992.
PJ Green.
Reversible jump Markov chain Monte
Carlo computation and Bayesian model determination.
Biometrika, 1995.
Chunhui Gu, Joseph J Lim, Pablo Arbel´ ez, and Jitendra
a
Malik. Recognition using regions. In CVPR, pages
1030–1037. IEEE, 2009.
S Gulwani and N Jojic. Program veriﬁcation as probabilistic inference. In ACM SIGPLAN Notices, 2007.
Liang Huang, Suphan Fayong, and Yang Guo. Structured perceptron with inexact search. In Proceedings of
the 2012 Conference of the North American Chapter of
the Association for Computational Linguistics: Human
Language Technologies, pages 142–151. Association for
Computational Linguistics, 2012.

SP Meyn and RL Tweedie. Computable bounds for geometric convergence rates of Markov chains. The Annals
of Applied Probability, 1994.
DJ Murdoch and PJ Green. Exact sampling from a continuous state space. Scandinavian Journal of Stat., 1998.
I Murray and R Salakhutdinov.
Notes on the KLdivergence between a Markov chain and its equilibrium
distribution. 2008.
S Petrov.
2011.

Coarse-to-ﬁne natural language processing.

JG Propp and DB Wilson. Exact sampling with coupled
Markov chains and applications to statistical mechanics. Random structures and Algorithms, 9(1-2):223–252,
1996.
GO Roberts and RL Tweedie. Bounds on regeneration
times and convergence rates for Markov chains. Stochastic Processes and their applications, 80(2):211–229,
1999.
JS Rosenthal. Minorization conditions and convergence
rates for markov chain monte carlo. JASA, 1995.
Evan Sandhaus. The new york times annotated corpus. Linguistic Data Consortium, Philadelphia, 6(12):e26752,
2008.
B Sapp, A Toshev, and B Taskar. Cascaded models for
articulated pose estimation. In ECCV, 2010.
R Sharma and A Aiken. From invariant checking to invariant inference using randomized search. In CAV, 2014.
Libin Shen, Anoop Sarkar, and Franz Josef Och. Discriminative reranking for machine translation. In NAACL,
pages 177–184, 2004.
Tianlin Shi, Jacob Steinhardt, and Percy Liang. Learning
where to sample in structured prediction. 2015.
RS Sutton, D Mcallester, S Singh, and Y Mansour. Policy
gradient methods for reinforcement learning with function approximation. In NIPS, 2000.
Paul Viola and Michael J Jones. Robust real-time face detection. International journal of computer vision, 57(2):
137–154, 2004.

Learning Fast-Mixing Models for Structured Prediction

Martin J Wainwright. Estimating the wrong graphical
model: Beneﬁts in the computation-limited setting. The
Journal of Machine Learning Research, 7:1829–1859,
2006.
David Weiss, Benjamin Sapp, and Ben Taskar. Sidestepping intractable inference with structured ensemble cascades. In NIPS, volume 1281, pages 1282–1284, 2010.
Payman Yadollahpour, Dhruv Batra, and Gregory
Shakhnarovich. Discriminative re-ranking of diverse
segmentations. In CVPR, pages 1923–1930. IEEE,
2013.

Learning Fast-Mixing Models for Structured Prediction

A. Proofs
˜
Proof of Proposition 3.1. We will in fact show that, for all k > 1, λk (A) = (1 − )λk (A), with the same eigenvector
˜ is different from A, all other eigenvectors are
for both matrices. In other words, while the stationary distribution of A
unchanged.
Let wk be the eigenvector of A corresponding to λk . First note that 1 wk = 0. This is because
1 Awk = 1 wk

(8)

1 Awk = λk 1 wk

(9)

since A is stochastic, and

since wk is an eigenvector of A. Since λk = 1, this implies that 1 wk = 0.
Now we have
˜
Awk = (1 − )Awk + u1 wk
= (1 − )λk wk ,
˜
˜
˜
which proves that λk (A) = (1 − )λk (A). In particular, λ2 (A) = (1 − )λ2 (A) ≤ 1 − . The mixing time of A is

1
˜ ,
1−λ2 (A)

and is therefore upper bounded by 1 , which completes the proof.
˜π ˜
Proof of Proposition 3.2. We can verify algebraically that A˜ = π , as follows:
˜π
A˜ = (1 − )A˜ + u1 π
π
˜
= (1 − )A(I − (1 − )A)−1 u + u
=

(1 − )A(I − (1 − )A)−1 + I u

= [(1 − )A + (I − (1 − )A)] (I − (1 − )A)−1 u
= (I − (1 − )A)−1 u
= π,
˜
˜
so that π is indeed the stationary distribution of A.
˜
Proof of Proposition 3.5. From the characterization of π in Proposition 3.2, we know that π is equal to
˜
˜
∞

(1 − )j Aj u.

(10)

j=0

The rest of the proof consists of determining some useful properties of dπ (π ). The most important (and the motivation for
deﬁning dπ in the ﬁrst place) is given in the following lemma, which we prove separately:
Lemma A.1. If π is the stationary distribution of A and A satisﬁes detailed balance, then dπ (Aπ ) ≤ λ2 (A)dπ (π ).
The other important property of dπ (π ) is convexity: dπ (wπ + (1 − w)π ) ≤ wdπ (π ) + (1 − w)dπ (π ), which follows
directly from the characterization of dπ (π ) as a Mahalanobis distance.
Putting these two properties together, we have
∞

(1 − )j dπ (Aj u)

dπ (˜ ) ≤
π
j=0
∞

(1 − )j λ2 (A)j dπ (u)

≤
j=0

≤
≤

1 − (1 − )λ2 (A)
1 − λ2 (A)

dπ (u),

dπ (u)

Learning Fast-Mixing Models for Structured Prediction

which completes the proof.
Proof of Lemma A.1. Recall we want to show that dπ (Aπ ) ≤ λ2 (A)dπ (π ). To see this, ﬁrst deﬁne S =
diag(π)−1/2 A diag(π)1/2 , which is symmetric by the detailed balance condition, and satisﬁes λk (S) = λk (A) by similarity. Furthermore, the top eigenvector of S is 1 diag(π)1/2 . Putting these together, we have
dπ (Aπ ) = diag(π)−1/2 (π − Aπ )
−1/2

= diag(π)

= S diag(π)

2

A(π − π )

−1/2

(π − π )

−1/2

≤ λ2 (S) diag(π)

2
2

(π − π )

2

= λ2 (S)dπ (π )
= λ2 (A)dπ (π ).
The inequality step S diag(π)−1/2 (π − π ) 2 ≤ λ2 (S) diag(π)−1/2 (π − π )
is orthogonal to the top eigenvector 1 diag(π)1/2 of S.

2

follows because diag(π)−1/2 (π − π )

Proof of Proposition 3.4. For any value of , the stationary distribution π of (1 − )A + u1 can be obtained by applying
˜
A a Geometric( )-distributed number of times to u (by Proposition 3.2). For 2 < 1 , it therefore sufﬁces to construct
a random variable F ≥ 0 such that if s ∼ F and t ∼ Geometric( 1 ) then s + t ∼ Geometric( 2 ); if we can do this,
then we can let B be the matrix that applies A an F -distributed number of times, and we would have B π 1 = π 2 ;
˜
˜
but B would clearly have stationary distribution π, and so Lemma 3.3 would give KL (π π 2 ) ≤ KL (π π 1 ) and
˜
˜
KL (˜ 2 π) ≤ KL (˜ 1 π), which is the desired result.
π
π
To construct the desired F , we use the fact that addition of random variables corresponds to convolution of the probability
mass functions, and furthermore represent the probability mass functions as formal power series; in particular, we let
∞

P[t = n | t ∼ F ]xn ,

f (x) =

(11)

n=0

and similarly
∞

P[t = n | t ∼ Geometric( )]xn

g (x) =
n=0
∞

(1 − )n xn

=
n=0

=

1 − (1 − )x

.

We want f (x)g 1 (x) to equal g 2 (x), so we take
g 2 (x)
g 1 (x)
2 1 − (1 −
=
1 1 − (1 −

f (x) =

1 )x
2 )x

∞

=

2

=

2
1

(1 −

1+

1

n
2)

− (1 −

n−1
(1
2)

−

1)

xn

n=1
∞

(1 −

1+

2)

n−1

(

1

−

2 )x

n

.

n=1

From this we see that the random variable F with probability function
2

P[t = n | t ∼ F ] =

(1 −
1
2

1

2)

n−1

(

1−

2)

: n=0
: n>0

(12)

Learning Fast-Mixing Models for Structured Prediction

satisﬁes the required property that F + Geometric( 1 ) = Geometric( 2 ). Note that the condition
here so that all of the probability masses are positive in the above expression.

2

<

1

is necessary

We can also prove the result purely algebraically. Motivated by the above construction, we deﬁne
B=
=

2 (I
2

−1
2 )A)

− (1 −

I +(

−

1

2 )A(I

1 (I

− (1 −

− (1 −

2 )A)

−1 −1
1 )A)
−1

.

1

By construction we have B π 1 = π 2 , but Taylor expanding the second expression for B shows that we can write it as
˜
˜
a (inﬁnite) convex combination of non-negative powers of A, and hence that B has stationary distribution π. This again
yields the desired result by Lemma 3.3.

Proof of Theorem 3.6. We use an equivalent characterization of the strong Doeblin parameter as the quantity Γ(A) =
y inf y A(y | y ). In the context of the Markov chain M , this yields
Γ(M b ) =

inf P[zb , yb | z0 , y0 ]

(zb ,yb )

(z0 ,y0 )

b

=

P[τa = τ | y0 ] × P[zb , yb | τa = τ ]

inf
(zb ,yb )

(z0 ,y0 )

τ =a

b

inf P[τa = τ | y0 ] × P[zb , yb | τa = τ ]

≥
(zb ,yb ) τ =a

y0

b

inf P[τa = τ | y0 ]

=

y0

τ =a

P[zb , yb | τa = τ ]
(zb ,yb )

b

inf P[τa = τ | y0 ]

=
τ =a

y0

= γa,b .
Finally, by Proposition 3.1, the spectral gap of M b is at least γa,b , hence the spectral gap of M is at least 1 γa,b , which
b
proves the theorem.

Proof of Corollary 3.7. Note that the time to transition from i to i + 1 is Geometric(δi )-distributed. Suppose we start
k−2
from an arbitrary j ∈ {0, . . . , k − 1}. Then the time t to get to k − 1 is distributed as i=j Geometric(δi ). t has
mean
2
δk−1

k−2 1
i=j δi

≤

1
δk−1 ,

and variance

k−2 1−δi
2
i=j δi

≤

1
.
2
2δk−1

In particular, with probability

1
2,

t lies between 0 and

. Now, consider the time t to get from k − 1 to 0; this is Geometric(δk−1 )-distributed, and conditioned on
2
δk−1 , t
δk−1 )2/δk−1

t being at least

at least (1 −
distributed according to
the probability that τ ≤

+t −
≥
2
δk−1
3
δk−1

2
δk−1

is also Geometric(δk−1 )-distributed. But t is at least

2
δk−1

with probability

1
16

(since δk−1 ≤ 1 ). Hence
2
+ Geometric(δk−1 ). But t

1
independently of j, t + t is, with probability at least 16 ,
+ t = τ by construction, and so we need only compute
1
; but this is just the probability that the geometric distribution is less than δk−1 , which is
−1

1
1 − (1 − δk−1 )1/δk−1 ≥ 1 − e−1 . Therefore, γ(t0 , t) ≥ 1−e ≥ 26 ; expanding the deﬁnitions of t0 and t, we have
16
1
that γ 2/δk−1 , 3/δk−1 ≥ 26 . Applying Theorem 3.6 then implies that the spectral gap of M is at least δk−1 , as was to be
78
shown.

Learning Fast-Mixing Models for Structured Prediction

Proof of Lemma 4.2. The key idea is to use the identity
pθ (z ∈ S)

∂f
∂x

= f (x) ∂ log f (x) in two places. We have
∂x

∂ log pθ (z ∈ S)
∂
=
pθ (z ∈ S)
∂θ
∂θ
∂pθ (z)
=
dz
∂θ
S
∂ log pθ (z)
dz
=
pθ (z)
∂θ
S
∂ log pθ (z)
z∈S ,
= pθ (z ∈ S)Ez
∂θ

which completes the lemma.

B. Correctness of Importance Sampling Algorithm
In Section 4.1 of the main text, we had a distribution u over Y and a Markov chain A(yt | yt−1 ) on the same space. We
def

then built a distribution over Y ∗ = T ≥0 {T } × Y T by sampling T ∼ Geometric( ), y0 ∼ u, and yt | yt−1 ∼ A for
y = 1, . . . , T (we use pT (y0:T ) to represent the distribution over y0:T given T ).
For a given y, we were interested in constructing an importance sampler for (T, y0:T ) | yT = y. The following Lemma
establishes the correctness of the importance sampler that was presented. We assume we are interested in computing the
expectation of some function g : Y ∗ → R and show that the given importance weights correctly estimate E[g].
Lemma B.1. For a distribution F , suppose that we sample T ∼ F and then sample y0:T −1 ∼ pT −1 . Let wt =
(1− )t
P[T ≥t|T ∼F ] A(y | yt−1 ). Consider the random variable
T
def

g =
ˆ

wt g(t, y0:t−1 , y).

(13)

t=0

Then
ET ∼F,y0:T −1 ∼pT −1 [ˆ] = ET ∼Geometric(
g

),y0:T ∼pT

[g(T, y0:T )I[yT = y]] .

Proof. We have
T

ET ∼F,y0:T −1 ∼p [ˆ] = ET ∼F,y0:T −1 ∼pT −1
g

wt g(t, y0:t−1 , y)
t=0

∞

P[T ≥ t | T ∼ F ]Ey0:t−1 ∼pt−1 [wt g(t, y0:t−1 , y)]

=
t=0
∞

(1 − )t Ey0:t−1 ∼pt−1 [A(y | yt−1 )g(t, y0:t−1 , y)]

=
t=0
∞

(1 − )t Ey0:t ∼pt [g(t, y0:t )I[yt = y]]

=
t=0

= ET ∼Geometric(
as was to be shown.

),y0:T ∼pT

[g(T, y0:T )I[yT = y]] ,

(14)

