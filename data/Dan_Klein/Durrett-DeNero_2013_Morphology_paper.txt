Supervised Learning of Complete Morphological Paradigms

Greg Durrett∗
Computer Science Division
University of California, Berkeley
gdurrett@cs.berkeley.edu

Abstract
We describe a supervised approach to predicting the set of all inﬂected forms of a lexical
item. Our system automatically acquires the
orthographic transformation rules of morphological paradigms from labeled examples, and
then learns the contexts in which those transformations apply using a discriminative sequence model. Because our approach is completely data-driven and the model is trained
on examples extracted from Wiktionary, our
method can extend to new languages without
change. Our end-to-end system is able to predict complete paradigms with 86.1% accuracy
and individual inﬂected forms with 94.9% accuracy, averaged across three languages and
two parts of speech.

1

Introduction

For natural languages with rich morphology, knowledge of how to inﬂect base forms is critical for both
text generation and analysis. Hand-engineered, rulebased methods for predicting inﬂections can offer
extremely high accuracy, but they are laborious to
construct and do not exist with full lexical coverage in all languages. By contrast, a large number
of example inﬂections are freely available in a semistructured format on the Web. The English Wiktionary1 is a crowd-sourced lexical resource that includes complete inﬂection tables for many lexical
items in many languages. We present a supervised
∗
1

Research conducted during an internship at Google.
http://en.wiktionary.org

John DeNero
Google, Inc.
denero@google.com

system that, given only data from Wiktionary, automatically discovers and learns to apply the orthographic transformations governing a language’s inﬂectional morphology.2
Our data-driven approach is designed to extend to
any language for which we have a substantial number of example inﬂection tables. The design of our
model is guided by three structural assumptions:
1. The inﬂections of many lexical items are
governed by a few repeated morphological
paradigms.
2. A morphological paradigm can be decomposed into independent orthographic transformation rules (including preﬁx, sufﬁx, and stem
changes), which are triggered by orthographic
context.
3. A base form is transformed in consistent, correlated ways to produce its inﬂected variants.
Learning proceeds in two stages that both utilize
the same training set of labeled inﬂection tables.
First, an inventory of interpretable transformation
rules is generated by aligning each base form to all
of its inﬂected forms. Second, a semi-Markov conditional random ﬁeld (CRF) (Sarawagi and Cohen,
2004) is trained to apply these rules correctly to unseen base forms. As we demonstrate experimentally,
the CRF is most effective when jointly predicting all
inﬂected forms of a lexical item together, forcing the
system to adopt a single consistent analysis of each
base form.
2

See http://eecs.berkeley.edu/~gdurrett for
our datasets and code.

Previous work has also described supervised and
semi-supervised approaches to predicting inﬂectional morphology (Yarowsky and Wicentowski,
2000; Wicentowski, 2004; Dreyer and Eisner, 2011).
Our approach differs primarily in its use of automatically extracted morphological rules and our discriminative prediction method which jointly models entire inﬂection tables. These modeling choices
are directly inspired by the data setting: Wiktionary
contains complete inﬂection tables for many lexical
items in each of a large number of languages, so it
is natural to make full use of this information with a
joint model of all inﬂected forms.
We evaluate our predictions on held-out Wiktionary inﬂection tables for three languages and two
parts of speech. Our language-independent method
predicts inﬂections for unseen base forms with accuracies ranging from 88.9% (German nouns) to
99.7% (Spanish verbs). For comparability with previous work, we also evaluate our approach on German verb forms in the CELEX lexical database
(Baayen et al., 1995). Our approach outperforms
the semi-supervised hierarchical Bayesian model of
Dreyer and Eisner (2011), while employing scalable exact inference and interpretable transformation rules.

2

I NFINITIVE
1 P, PRES , SING
2 P, PRES , SING
3 P, PRES , SING
PAST PART.
...

schleichen
schleiche
schleichst
schleicht
geschlichen
...

Table 1: Two partial inﬂection tables for the German
verbs machen (to make) and schleichen (to crawl).

formation rules that have been extracted from example tables. As an example of our rule application process, to inﬂect machen appropriately in the
forms listed in Table 1, one could apply the following rules:
1. Replace a sufﬁx -en with -e for ﬁrst person, -st
for second person, -t for third person, and -t for
the past participle.
2. Add a preﬁx ge- for the past participle.
To inﬂect schleichen, one could apply a larger set of
three rules:
1. Replace a sufﬁx -en with -e for ﬁrst person, -st
for second person, -t for third person, and -en
for the past participle.

Background: Inﬂectional Morphology

Among the valid words W and parts of speech P
in a language, the base forms B ⊂ W × P are the
canonical forms of the language’s lexical items. A
base form relates to an inﬂected form via an inﬂectional relation (b, w, a), where b ∈ B is a base form,
w ∈ W is the inﬂected form, and a is a vector of
morphological attributes. An inﬂection table T (b) is
the set of all such relations for a base form b.
Two partial inﬂection tables are shown in Table 1,
for the base forms (inﬁnitives) of the German verbs
machen and schleichen, containing such inﬂectional relations as (machen, mache, [1 P, PRES , SING])
and (machen, gemacht, [PAST PART.]). Only a
small sample of the valid attribute combinations are
shown; a full inﬂection table for a German verb in
our Wiktionary dataset contains 27 relations.
The goal of this paper is to learn how to map b
to T (b). We generate candidate inﬂection tables by
applying compact, interpretable orthographic trans-

machen
mache
machst
macht
gemacht
...

2. Add a preﬁx ge- for the past participle.
3. Delete the ﬁrst e for the past participle.
The inﬂection tables of other German verbs can be
generated using precisely the same rules above, and
different inﬂection patterns may share rules, such as
the repeated rule 2. This example illustrates one of
our chief assumptions, that the inﬂections of many
base forms can be modeled with a small number of
such rules, applied in various combinations.

3

Learning Transformation Rules

From a training set of inﬂection tables
{T (b1 ), ..., T (bn )}, our system learns a set of
orthographic transformation rules. A rule is a function R : s, a → s that takes as input a substring s of
a base form and an attribute vector a and outputs a
replacement substring s . The sufﬁx transformation
from Section 2 for machen can be described using a

Algorithm 1 Learning rules from examples.
Input: n training instances T (b1 ), . . . , T (bn )
Rule set R ← {}
for i ← 1 to n do
Changed source spans C ← {}
for all a ∈ A do
Ca ← P ROJECT S PANS(A LIGN(bi , Ta (bi )))
C ← U NION S PANS(C, Ca )
end for
for all c ∈ C do
R ← R ∪ {E XTRACT RULE(c)}
end for
end for
return R

Span Merging

Alignment
schleiche n

||||||||| D
schleiche
schl e ich en

schl e ichen

I I|||| D |||||
geschl

ichen

R(en, [3 P, PRES , SING]) = t
R(en, [PAST PART.]) = t
Our method for learning rules from examples is
described in Algorithm 1 and depicted in Figure 1.
We extract rules from each observed inﬂection table
T (bi ) independently, and the ﬁnal set of rules is simply the union of the sets of rules learned from each
example. The procedure for a single inﬂection table
has three steps:
Alignment: Align each inﬂected form to the base
form with an iterated edit-distance algorithm.
Span Merging: Extract the set of spans of the
base form that changed to produce the inﬂected
form, and take their union across all attribute vectors to identify maximal changed spans.
Rule Extraction: Extract a rule for each maximal changed span.
Alignment. For each setting of attributes a, we
ﬁnd the lowest-cost transformation of the base form
b into the corresponding inﬂected form Ta (b) using
single-character insertions, deletions, and substitutions. This minimum edit distance calculation is
computed via the following recurrence, where i is
an index into the base form b and j is an index into

schl ich

Rule Extraction

schleichen
schleiche
schl ich
geschl ichen

...

rule with four entries:

R(en, [2 P, PRES , SING]) = st

schleiche

|||| D ||| D D g e s c h l i c h e n
...
schl ich

...

R(en, [1 P, PRES , SING]) = e

schleichen

Figure 1: Demonstration of the rule extraction algorithm
with the base form schleichen and three inﬂected forms:
schleiche (ﬁrst person singular present), schlich (ﬁrst person singular past), and geschlichen (past participle). We
ideally want to extract appropriate transformation rules
like those described in Section 2. In the alignment step,
we minimize the edit distance between each inﬂected
form and the base form to identify changed spans. In
the span merging step, we project changes onto the base
form and take the union of adjacent or overlapping spans.
In the rule extraction step, we project these spans back
onto the inﬂected forms to identify transformation rules.

an inﬂected form Ta (b):
L(i, j) = min{L(i, j − 1) + I,
L(i − 1, j) + D,
L(i − 1, j − 1) + S(i, j)}
I, D, and S are insertion, deletion, and substition costs, respectively. Tracing the computation of
L(len(b), len(Ta (b))) yields an optimal sequence of
edit operations. The alignments output by this procedure are depicted in the ﬁrst panel of Figure 1.
The most typical cost scheme sets I = 1, D = 1,
and S(i, j) = (1 − I[match(i, j)]), i.e. 0 if the ith
character of b is the same as the jth character of
Ta (b), and 1 otherwise. However, this cost scheme
did not yield intuitive alignments for some of our
training instances. For example, in the case of the
verb denken aligning to its past participle gedacht,

the initial d and g will be aligned and the following e’s will be aligned, preventing the algorithm
from recognizing the addition of the preﬁx ge-. To
solve this problem, we use a dynamic edit distance
cost scheme in which I, D, and unmatched substitutions all have a cost of 0. Matched substitutions
have a negative cost −ci , where i is the index in the
base form and ci is the number of other inﬂected
forms for which i is aligned to a matching character. The inﬂected forms are iteratively realigned
with the base form until the ci converge (Eisner,
2002; Oncina and Sebban, 2006). This cost scheme
encourages a single consistent analysis of the base
form as it aligns to all of its inﬂected forms.
Span Merging. From each aligned pair of words,
the P ROJECT S PANS procedure identiﬁes sequences
of character edit operations with contiguous spans of
the base form. We construct a set of changed spans
Ca of b as follows: include the span (i, j) if and
only if no characters between i and j were aligned
to matching characters in Ta (b) and no smaller span
captures the same set of changes. Projected spans
for the inﬂected forms of schleichen are shown in
the “Span Merging” panel of Figure 1.
The U NION S PANS procedure combines two sets
of spans by iteratively merging any two spans that
are overlapping or adjacent. Repeating this procedure to accumulate spans for each setting of a yields
the set C of maximal changed spans for a base form.
Any span in C is bordered either by word boundaries
or by characters that are match-aligned in every inﬂected form, meaning that we have isolated a region
characterized by a particular orthographic transformation.
Rule Extraction. The ﬁnal step of Algorithm 1
extracts one rule for each maximal changed span of
the base form. The Rule Extraction panel of Figure 1
depicts how maximal changed spans in the base
form correspond to transformation rules. Because
U NION S PANS guarantees that match-aligned characters border each maximal changed span, there is
no ambiguity about the segmentation of transformations. The E XTRACT RULE procedure produces one
rule R(s, a) corresponding to each changed span.

Attributes
INFINITIVE

Sufﬁx
en
en
e
e
te
t
st
test
st
t
t
te
t
en
...
...

n
e
te
st
test
t
te
t
...

1 P, PRES , SING
1 P, PAST, SING
2 P, PRES , SING
2 P, PAST, SING
3 P, PRES , SING
3 P, PAST, SING
PAST PART.
...
Label Rsuf,1 Rsuf,2 Rsuf,3 Rsuf,4

Stem Pre.
e
e
e
e
...

ge
...

Rst,1

Rpre,1

Table 2: Each column is an example of a morphological
transformation rule extracted by our approach. The ﬁrst
four are sufﬁx changes; these apply to, in order, regular
verbs such as machen, verbs ending in -zen or -sen such as
setzen, verbs such as schleichen and beheben, and verbs
ending in -ern or -eln such as sprenkeln. The stem change
occurs in strong verbs of the ﬁrst class such as schleichen,
greifen, and streiten. Finally, we learn that ge- can be
added as a preﬁx to indicate the past participle.

rules are interpretable descriptions of common inﬂection patterns.

4

Applying Transformation Rules

For a novel base form b, the inventory of learned
transformation rules R = {R(s, a)} can typically
generate many candidate inﬂection tables T (b) for
us to choose between. A rule can potentially apply
to a base form in a number of places; we deﬁne an
anchored rule A = (R, i, j, b) to be the application
of R to a span (i, j) in b. A is only a valid anchoring
if the substring of b between i and j matches the
input of rule R.
Given a set A of non-overlapping anchored rules
for b, each entry of T (b) can be deterministically
produced by rewriting each anchored rule’s span
(i, j) using the rule R. Therefore, the task of predicting T (b) is equivalent to selecting a coherent subset
A of anchored rules from the set of all possible anchored rules for this base form. By coherent, we
mean that the selected rules are anchored to nonoverlapping, non-adjacent3 spans of b. Figure 2a
shows two coherent anchored rule subsets for schleichen (the top one being correct). Underlining indi3

Table 2 contains examples of the transformation
rules we extract from German verbs. The extracted

en
e
te
st
test
t
te
t
...

During rule extraction, any adjacent changed spans are
merged into a single rule. Disallowing adjacent spans here
therefore prevents us from synthesizing new rules.

cates length-one spans S = (i, i + 1, b) that are not
part of any anchored rule in A. We denote the set of
such spans by S(A); this set is uniquely deﬁned for
the given base form by the selected anchored rules.
We use a log-linear model to place a conditional
distribution over valid anchored rule subsets A given
the base form b:


pw (A|b) ∝ exp wT 

φ(A) +

A∈A

ψ(S)
S∈S(A)

where w is a weight vector, φ(A) computes a feature vector for anchored rule A, and ψ(S) computes
a feature vector for preserved spans S. We train
this model to maximize the regularized conditional
log-likelihood of the training data, which consists of
base forms bi and gold subsets of anchored rules A∗
i
derived using Algorithm 1 on the gold inﬂection tables.
n

log p(A∗ |bi ) +
i

L(w) =
i=1

γ
w 2.
2

We ﬁnd w∗ = arg maxw L(w) using L-BFGS (Liu
∂L
and Nocedal, 1989), which requires computing ∂w .
This gradient takes the standard form of the difference between gold feature counts and expected feature counts under the model:


n
∂L

=
φ(A) +
ψ(S) −
∂w
i=1
A∈A∗
S∈S(A∗ )
i
i


Epw φ(A) +


A∈A(R,b)

Epw ψ(S) − γw
S∈S(b)

where, by a slight abuse of notation, S(b) is the set
of all length-one spans of b.
In general, the normalizer of pw and the expectation over pw cannot be computed directly, since
there may be exponentially many coherent subsets
of anchored rules. However, we note that A and
its corresponding S(A) form a segmentation of the
base form b, with features decomposing over individual segments. Our model can therefore be viewed
a semi-Markov model over b (Sarawagi and Cohen, 2004); more precisely, a zeroth-order semiMarkov model, since we do not include features on
state transitions. At training time, we can use the

a)

schleichen

Rpre,1

Rst,1

Rsuf,3

schleichen
Rpre,1

Rst,1

b) R :l[e] S:c[h]
st,1
schleichen
Rst,1 :[e]i S:[h]e

Figure 2: a) Two possible anchored rule sets for schleichen. The indicated rules are preﬁx, stem, and sufﬁx
rules as found in Table 2. The top anchoring is correct,
while the bottom misplaces the stem change and does not
include a sufﬁx change. Underlined letters indicate preserved spans S. b) Bigram context features computed by
φ(Rst,1 ), where the stem change is applied to the highlighted e, and similar features computed by ψ(S) for the
underlined h, which is unchanged by the applied rules.

forward-backward algorithm for semi-Markov models to compute the gradient of pw , and at test time,
the Viterbi algorithm can exactly ﬁnd the best rule
ˆ
subset under the model: A = arg maxA pw (A|b).
Features. The feature function φ captures contextual information in the base form surrounding the
site of the anchored rule application. It is well understood that different morphological rules may require
examining different amounts of context to apply correctly (Kohonen, 1986; Torkkola, 1993; Shalonova
and Gol´ nia, 2010); to this end, we will use local
e
character n-gram features, which have been successfully applied to related problems (Jiampojamarn et
al., 2008; Dinu et al., 2012).
A sketch of our feature computation scheme is
shown in Figure 2b. Our basic feature template is
an indicator on a character n-gram with some offset from the rule application site, conjoined with the
identity of the rule R being applied. Our features
look at variable amounts of context: we include features on unigrams through 4-grams, starting up to
ﬁve letters behind the anchored rule span and ending up to ﬁve letters past the anchored rule span.
These features can model most hand-coded morphological rules, but are in many cases more numerous
than necessary. However, we ﬁnd that regularization
is effective at balancing high model capacity with
generalization, and reducing the size of the feature
set empirically harms overall accuracy.
We also employ factored features that only look at
predictions over particular inﬂected forms; these are

coarser features that are shared between two rules
when they predict the same orthographic change for
a particular setting of attributes. These features are
indicators on Ra (the restriction of R to attributes a),
the context n-gram, and its offset from the span.
The feature function ψ is almost identical to φ,
but instead of indicating a rule appearing in some
context, it instead indicates that a particular lengthone span is being preserved in its n-gram context.
Examples of ψ features are shown in Figure 2b.
Pruning. Thus far, the only requirement on an anchoring A is that the source side of its rule R must
match the span it is anchored to in the base form
b. We further ﬁlter the set of possible A as follows:
if every occurrence of R in the training set is preceded by the same character (including a start-ofword character) or followed by the same character
(including an end-of-word character), any anchoring
A must be preceded or followed accordingly. This
stipulation is most useful in restricting preﬁxing or
sufﬁxing insertions, which have an empty source
side, to apply only at the beginnings or ends of base
forms (rather than at arbitrary points throughout). In
doing so, we prune out many erroneous anchored
rules and speed up inference substantially without
prohibiting correct rule applications.

5

Wiktionary Morphology Data

Our primary source of supervised inﬂection table
data is English Wiktionary. The collective editors
of English Wiktionary have created complete, consistent inﬂection tables for many lexical items in
many languages. Previous work has successfully
parsed other information from Wiktionary, such as
parts of speech, glosses, and etymology (Zesch et
al., 2008; Li et al., 2012); however, to our knowledge, inﬂection tables have not previously been extracted in a format easily amenable to natural language processing applications. These inﬂection tables are challenging to extract because the layout of
tables varies substantially by language (beyond the
expected changes due to differing sets of relevant
morphological attributes), and some tables contain
annotations in addition to word forms.
In order to extract this data, we built a Wiktionary
scraper which generates fully structured output by
interpreting the templates that generate the rendered

Lang/POS
DE - NOUNS
DE - VERBS
ES - VERBS
FI - NOUNS
FI - VERBS

Base forms
2764
2027
4055
40589
7249

Inﬂ. forms per base
8
27
57
28
53

Table 3: Number of full morphology tables extracted
from Wiktionary for each language and part of speech
pair that we considered, as well as the number of inﬂected
forms associated with each base form.

inﬂection tables. Table 3 gives statistics for the number of base forms and inﬂected forms extracted from
Wikitionary. When multiple forms were listed in an
inﬂection table for the same base form and attribute
vector, we selected the ﬁrst in linear order; applying
the same principle, we also kept only the ﬁrst inﬂection table when more than one was listed for a given
base form. Furthermore, base forms and inﬂected
forms separated by spaces, hyphens, or colons were
discarded. As a result, we discarded German verbpreposition compounds such as ablehnen4 and Spanish reﬂexives such as lavarse.

6

Experiments

We evaluate our model under two experimental conditions. First, we use the German verb lexicon in
the CELEX lexical database (Baayen et al., 1995)
with the same train/test splits as Dreyer and Eisner
(2011). Second, we train on our Wiktionary data described in Section 5 and evaluate on held-out forms
from this same dataset.
In each case, we evaluate two variants of our
model in order to examine the importance of jointly
modeling the production of the entire inﬂection table. Our J OINT model is exactly as deﬁned in Section 4. For our FACTORED model, the dictionary of
rules is extracted separately for each setting of the
attributes a; i.e., we run the entire procedure in Section 3 with only one inﬂected form at a time and
forego the U NION S PANS step. A separate prediction model is trained for each a and so features are
not shared across multiple predictions as they are in
the J OINT case. Note that this FACTORED approach
4

This class of verbs was also ignored by Dreyer and Eisner
(2011).

NA¨VE
I
FACTORED
J OINT
DE11
DE11+C ORPUS
O RACLE

No. of training examples
50
100
200
87.61 87.70
87.70
89.61 91.40
92.64
90.47 92.31
93.18
89.9
91.5
90.9
92.2
95.47 96.09
96.77

Table 4: Accuracies on reconstructing individual inﬂected forms in CELEX, averaged over the 5415 inﬂection tables in each of 10 test sets. Three training set
sizes are reported. DE11 indicates a reported result from
Dreyer and Eisner (2011), with blank results unreported
in that work. Our FACTORED model is able to do approximately as well as the DE11 baseline method, and our
J OINT model performs better yet, performing comparably to DE11+C ORPUS, which uses additional monolingual text. All models substantially outperform the NA¨VE
I
sufﬁxing baseline. The relatively low O RACLE accuracy
indicates that some errors arise from failing to apply rules
that are not attested in these small training sets.

can produce inﬂection tables that the J OINT model
cannot, due to its ability to “mix and match” orthographic changes in the same inﬂection table.
We also evaluate a NA¨VE method for applying
I
the joint rules which selects the most common sufﬁx
rule available after pruning.5 Finally, we report the
O RACLE accuracy attainable with the morphological rule dictionary of the J OINT model.
For our conditional likelihood objective, we use
γ = 0.0002; this parameter and the feature set were
tuned on a small development set and held ﬁxed for
all experiments.
6.1

CELEX Experiments

Dreyer and Eisner (2011) construct ten train/test
splits of the 5615 German verb forms in the CELEX
lexical database, keeping 200 forms for training in
each case, which they further subsample. These random splits serve to control for instability due to the
small training set sizes. Each inﬁnitive verb form
has 22 corresponding inﬂected forms capturing variation such as person, number, mood, and tense.
5

For example, for German verbs ending in -en, this applies
the most regular -en sufﬁx change, that exhibited by machen
and many other verbs.

Table 4 shows our results compared to those of
Dreyer and Eisner (2011). The FACTORED model
performs on par with the DE11 baseline model, but
the stronger performance of the J OINT model indicates that making joint predictions is important.
With 100 training examples, our model is able to
equal the performance of DE11+C ORPUS, which
additionally uses ten million tokens of monolingual
German text.
We emphasize that this is not the data condition
for which our model was designed. It is unfavorable for two reasons: ﬁrst, feature-rich models can
be learned more stably on larger training sets, and
second, the train/test splits are chosen randomly, and
therefore the test sets may contain completely irregular verbs using morphological rules that we have
never observed. As can be seen from the O RA CLE results in Table 4, a substantial fraction of the
missed test examples cannot be produced using our
extracted rules simply because we have not seen the
relevant examples; in many cases, even a human
could not generalize correctly from the given examples without exploiting external knowledge of the
German language.
6.2

Held-Out Wiktionary Data

Our algorithm was designed with the fundamental
assumption that the training set should be a comprehensive description of the morphology of a given
language, which is not true for the CELEX data. In
order to evaluate on a broader set of languages under
these training conditions, we turn to our Wiktionary
data. For each language and part of speech, we train
on all but 400 inﬂection tables, holding back 200 examples as a development set and 200 examples as a
blind test set.6 The forms selected for the development and test data were purposely chosen not to be
among the 200 most frequently occurring forms in
the language, since these common cases can be easily memorized from Wiktionary.
Results are shown in Table 5. As with the CELEX
results, we see that the joint prediction improves accuracy over the factored model, obtaining a 9% error reduction on individual forms and a 35% error
reduction on exact match. The more pronounced
6

For Finnish nouns, because there were so many inﬂection
tables, we trained only on the ﬁrst 6000 examples. Using more
examples did not signiﬁcantly change performance.

Lang/POS
DE - VERBS
DE - NOUNS
ES - VERBS
FI - VERBS
FI - NOUNS
AVG

NA¨VE
I
42.0
12.0
81.5
33.5
31.0
40.0

Exact table match
FACT. J OINT O RACLE
74.5
85.0
99.5
74.0
79.5
98.5
93.5
95.0
99.5
82.0
87.5
99.5
69.0
83.5
100.0
78.6
86.1
99.4

Individual form accuracy
NA¨VE FACT. J OINT O RACLE
I
89.13
94.76 96.19
99.98
49.06
88.31 88.94
99.25
97.20
99.61 99.67
99.99
75.32
97.23 96.43
99.86
61.23
92.14 93.41
100.00
74.39
94.41 94.93
99.81

Table 5: Accuracies on reconstructing complete inﬂection tables and individual inﬂected forms for held-out base forms
in our Wiktionary dataset. Results are shown for our fully J OINT model, a FACTORED model that predicts individual
inﬂected forms independently, a NA¨VE baseline that picks the most common applicable sufﬁx rule, and an O RACLE
I
that selects the best inﬂection table within our model’s capacity. For each language and part of speech, regardless of
training set size, evaluation is based on a blind test set of 200 held-out forms.

improvement on exact match is unsurprising, since
we expect that the joint predictions should get inﬂection tables correct in an “all-or-nothing” fashion,
whereas factored predictions are more likely to reﬂect divergent feature weights of the different component models. The NA¨VE baseline performs rather
I
poorly overall, indicating our algorithm is being sophisticated about applying more than just the most
common changes. Finally, we note that the O RA CLE performance is much higher in this case than
on the CELEX data, conﬁrming our intuition that
with the appropriate level of supervision our model
at least has the capacity to make correct predictions
in almost every case.
6.3

Error Analysis

We conducted an error analysis on the output of
our J OINT model on German nouns. From 2364
paradigms, we learn 53 different orthographic transformation rules, of which our 200-example development set exhibits 14.7
On our development set, 196 inﬂection tables are
within the capacity of our model. Of those 196, 159
are exactly correct. In Table 6, we show the top
six rules by frequency in the development set, along
7
Nineteen of our 53 extracted rules only occur on one example; this suggests a few reasons that fewer rules are applied
than are extracted. First, very common base forms with irregular morphology may give rise to completely irregular rules.
Second, our edit distance alignment procedure can sometimes
merge two adjacent rules if the orthographic context is such that
there are multiple minimum-cost analyses. Finally, errors and
inconsistencies in Wiktionary can yield nonsense rules that are
never applied elsewhere.

NOM , SING
NOM , PL

n

e

n

e

n

en
es
e
Krieg
48
72.9
89.6
80.4

ACC , SING
ACC , PL
DAT, SING
DAT, PL
GEN , SING
GEN , PL
Example
Gold
Prec
Rec
F1

n
Klasse
49
95.7
91.8
93.8

a
¨
a
a
¨
a
a
¨
a
a
¨
a
Haus
26
88.0
84.6
86.3

en
en
n
s
Nutzer
26
82.8
92.3
87.3

en
en
Frau
20
87.0
100.0
93.0

Table 6: Breakdown of errors by morphological rule being applied by the J OINT model on the DE - NOUNS development set. We show the rule itself, treating the nominative singular as the base form, an example of a German
word using that rule, and then the model’s accuracy at
predicting applications of that rule. Errors are spread out
over many rules, but it generally appears that common
rules are to blame for the errors that are made, due in
large part to gender confusion in this case.

with the precision, recall, and F-measure that our
model attains for each rule.8 These rules are mostly
interpretable: for example, the ﬁrst two columns
correspond to common sufﬁx rules for feminine and
masculine nouns, respectively. Our model’s performance is consistently high for each of the rules
shown, including a stem change (a changing to a
¨
in plural forms), providing further evidence that our
model is useful for modeling rarer morphological
8

Gold rules are obtained by running our rule extraction procedure over the examples in question.

paradigms as well as more common ones.
As a concrete example of an error our model does
make, L¨ we (lion) is incorrectly predicted to have
o
the ﬁrst sufﬁx, instead of the correct sufﬁx (not
shown) which adds an -n for accusative, genitive,
and dative singular as well. However, making this
prediction correctly is essentially beyond the capacity of a model based purely on orthography. Words
ending in -e are commonly feminine, and none of
our other training examples end in -we, so guessing that L¨ we follows a common feminine inﬂeco
tion pattern is reasonable (though L¨ we is, in fact,
o
masculine). Disambiguating this case requires either features on observed genders, a more complex
model of the German language, or observing the
word in a large corpus. Generally, when the model
fails, as in this case, it is because of a fundamental
linguistic information source that it does not have
access to.

7

2008) or decoding (Toutanova and Cherry, 2009)
steps similar to those of our model, but none attempt
to jointly predict a complete inﬂection table based
on automatically extracted rules.
Some previous work has addressed the joint analysis (Zajac, 2001; Monson, 2008) or prediction
(Lind´ n and Tuovila, 2009; Dinu et al., 2012) of
e
whole inﬂection tables, as we do, but rarely are
both aspects addressed simultaneously and most approaches are tuned to one particular language or
use language-speciﬁc, curated resources. In overall setup, our work most closely resembles that of
Dreyer and Eisner (2011), but they focus on incorporating large amounts of raw text data rather than
using large training sets effectively.
Broadly similar techniques are also employed in
systems to ﬁlter candidate rules and aid in human annotation of paradigms (Zajac, 2001; Forsberg et al.,
2006; D´ trez and Ranta, 2012) for resources such as
e
Grammatical Framework (Ranta, 2011).

Related Work

Much of the past work on morphology has focused
on concatenative morphology using unsupervised
methods (Goldsmith, 2001; Creutz and Lagus, 2007;
Monson, 2008; Poon et al., 2009; Goldwater et al.,
2009) or weak forms of supervision (Snyder and
Barzilay, 2008). These methods can handle aspects
of derivational morphology that we cannot, such as
compounding, but we can handle a much larger subset of inﬂectional morphology, including more complex preﬁx and sufﬁx rules, stem changes, and irregular forms. Some unsupervised work has speciﬁcally targeted these sorts of phenomena by, for example, learning spelling rules for mildly nonconcatenative cases (Dasgupta and Ng, 2007; Naradowsky and Goldwater, 2009) or mining lemma-base
form pairs from a corpus (Schone and Jurafsky,
2001), but it is extremely difﬁcult to make unsupervised methods perform as well as supervised approaches like ours.
Past supervised work on nonconcatenative inﬂectional morphology has typically targeted individual
pairs of base forms and inﬂected forms for the purposes of inﬂection (Clark, 2001) or lemmatization
(Yarowsky and Wicentowski, 2000; Wicentowski,
2004; Lind´ n, 2008; Toutanova and Cherry, 2009).
e
Some of these methods may use analysis (Lind´ n,
e

8

Conclusion

In this work, we presented a method for inﬂecting
base forms in morphologically rich languages: we
ﬁrst extract orthographic transformation rules from
observed inﬂection tables, then learn to apply these
rules to new base forms based on orthographic features. Training examples for our supervised method
can be collected from Wiktionary for a large number
of languages and parts of speech. The changes we
extract are interpretable and can be associated with
particular classes of words. Moreover, our model
can successfully apply these changes to unseen base
forms with high accuracy, allowing us to rapidly
generate lexicons for new languages of interest.
Our Wiktionary datasets and an opensource version of our code are available at
http://eecs.berkeley.edu/~gdurrett

Acknowledgments
We are grateful to Klaus Macherey and David Talbot
for assistance with the examples and helpful discussions throughout the course of this work. We would
also like to thank the three anonymous reviewers for
their useful comments.

References
R. H. Baayen, R. Piepenbrock, and L. Gulikers. 1995.
The CELEX Lexical Database (Release 2). Linguistic
Data Consortium, University of Pennsylvania.
Alexander Clark. 2001. Partially Supervised Learning
of Morphology with Stochastic Transducers. In Proceedings of Natural Language Processing Paciﬁc Rim
Symposium, pages 341–348, Tokyo, Japan.
Mathias Creutz and Krista Lagus. 2007. Unsupervised
Models for Morpheme Segmentation and Morphology
Learning. ACM Transactions on Speech and Language Processing, 4(1):3:1–3:34, Feb.
Sajib Dasgupta and Vincent Ng. 2007. High Performance, Language-Independent Morphological Segmentation. In Proceedings of the North American
Chapter of the Association for Computational Linguistics.
Gr´ goire D´ trez and Aarne Ranta.
e
e
2012.
Smart
Paradigms and the Predictability and Complexity of
Inﬂectional Morphology. In Proceedings of the European Chapter of the Association for Computational
Linguistics.
Liviu P. Dinu, Vlad Niculae, and Octavia-Maria Sulea.
¸
2012. Learning How to Conjugate the Romanian
Verb: Rules for Regular and Partially Irregular Verbs.
In Proceedings of the European Chapter of the Association for Computational Linguistics.
Markus Dreyer and Jason Eisner. 2011. Discovering
Morphological Paradigms from Plain Text Using a
Dirichlet Process Mixture Model. In Proceedings of
Empirical Methods in Natural Language Processing,
pages 616–627, Edinburgh, Scotland, UK.
Jason Eisner. 2002. Parameter Estimation for Probabilistic Finite-State Transducers. In Proceedings of the Association for Computational Linguistics.
Markus Forsberg, Harald Hammarstr¨ m, and Aarne
o
Ranta. 2006. Morphological Lexicon Extraction from
Raw Text Data. In Proceedings of Advances in Natural Language Processing.
John Goldsmith. 2001. Unsupervised Learning of the
Morphology of a Natural Language. Computational
Linguistics, 27(2):153–198, June.
Sharon Goldwater, Thomas L. Grifﬁths, and Mark Johnson. 2009. A Bayesian Framework for Word Segmentation: Exploring the Effects of Context. Cognition,
112(1):21–54.
Sittichai Jiampojamarn, Colin Cherry, and Grzegorz
Kondrak. 2008. Joint Processing and Discriminative Training for Letter-to-Phoneme Conversion. In
Proceedings of the Association for Computational Linguistics.
Teuvo Kohonen. 1986. Dynamically Expanding Context, With Application to the Correction of Symbol

Strings in the Recognition of Continuous Speech. In
Proceedings of the International Conference on Pattern Recognition.
Shen Li, Jo˜ o V. Graca, and Ben Taskar. 2012. Wiki-ly
a
¸
Supervised Part-of-speech Tagging. In Proceedings of
Empirical Methods in Natural Language Processing.
Krister Lind´ n and Jussi Tuovila. 2009. Corpus-based
e
Paradigm Selection for Morphological Entries. In
Proceedings of the Nordic Conference of Computational Linguistics.
Krister Lind´ n. 2008. A Probabilistic Model for Guesse
ing Base Forms of New Words by Analogy. In Proceedings of Computational Linguistics and Intelligent
Text Processing.
Dong C. Liu and Jorge Nocedal. 1989. On the limited
memory BFGS method for large scale optimization.
Mathematical Programming, 45(3):503–528, December.
Christian Monson. 2008. ParaMor: From Paradigm
Structure to Natural Language Morphology Induction.
Ph.D. thesis, Carnegie Mellon University.
Jason Naradowsky and Sharon Goldwater. 2009. Improving Morphology Induction by Learning Spelling
Rules. In Proceedings of the International Joint Conferences on Artiﬁcial Intelligence.
Jose Oncina and Marc Sebban. 2006. Learning Stochastic Edit Distance: Application in Handwritten Character Recognition. Pattern Recognition, 39(9):1575–
1587, September.
Hoifung Poon, Colin Cherry, and Kristina Toutanova.
2009. Unsupervised Morphological Segmentation
with Log-Linear Models. In Proceedings of the North
American Chapter of the Association for Computational Linguistics.
Aarne Ranta. 2011. Grammatical Framework: Programming with Multilingual Grammars. CSLI Publications, Stanford.
Sunita Sarawagi and William W. Cohen. 2004. SemiMarkov Conditional Random Fields for Information
Extraction. In Advances in Neural Information Processing Systems 17.
Patrick Schone and Daniel Jurafsky. 2001. KnowledgeFree Induction of Inﬂectional Morphologies. In Proceedings of the North American Chapter of the Association for Computational Linguistics.
Ksenia Shalonova and Bruno Gol´ nia. 2010. Weakly Sue
pervised Morphology Learning for Agglutinating Languages Using Small Training Sets. In Proceedings of
the Conference on Computational Linguistics.
Benjamin Snyder and Regina Barzilay. 2008. Unsupervised Multilingual Learning for Morphological Segmentation. In Proceedings of the Association for Computational Linguistics.

Kari Torkkola. 1993. An Efﬁcient Way to Learn English
Grapheme-to-Phoneme Rules Automatically. In Proceedings of the International Conference on Acoustics,
Speech, and Signal Processing: Speech Processing Volume II.
Kristina Toutanova and Colin Cherry. 2009. A Global
Model for Joint Lemmatization and Part-of-Speech
Prediction. In Proceedings of the Association for
Computational Linguistics.
Richard Wicentowski. 2004. Multilingual Noise-Robust
Supervised Morphological Analysis Using the WordFrame Model. In Proceedings of the ACL Special Interest Group in Computational Phonology.
David Yarowsky and Richard Wicentowski. 2000. Minimally Supervised Morphological Analysis by Multimodal Alignment. In Proceedings of the Association
for Computational Linguistics.
R´ mi Zajac. 2001. Morpholog: Constrained and Supere
vised Learning of Morphology. In Proceedings of the
Conference on Natural Language Learning.
Torsten Zesch, Christof M¨ ller, and Iryna Gurevych.
u
2008. Extracting Lexical Semantic Knowledge from
Wikipedia and Wiktionary. In Proceedings of Language Resources and Evaluation.

